<!doctype html>
<!--
README (GitHub Pages deploy)
- Put this file at your repo root as `index.html`
- Commit & push to GitHub
- In GitHub: Settings → Pages → Build and deployment → Source: Deploy from a branch
- Select Branch: `main` (or `master`) and Folder: `/ (root)`
- Save. Your game will appear at: https://<username>.github.io/<repo>/

Neon Rage Dodge
- Mobile-first, 2-lane toggle reaction dodger
- Controls: Tap/Click anywhere or press Space to toggle lanes
- Best score saved in localStorage key: "neon-rage-dodge-best"
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <meta name="theme-color" content="#090716" />
    <title>Neon Rage Dodge</title>
    <style>
      :root {
        --bg0: #070513;
        --bg1: #0b0730;
        --cyan: #39f6ff;
        --magenta: #ff34d2;
        --purple: #8b5cff;
        --text: rgba(240, 248, 255, 0.92);
        --muted: rgba(240, 248, 255, 0.72);
        --panel: rgba(5, 6, 14, 0.55);
        --panel2: rgba(5, 6, 14, 0.72);
        --stroke: rgba(57, 246, 255, 0.25);
      }

      * { box-sizing: border-box; }

      html, body {
        height: 100%;
        margin: 0;
        background: radial-gradient(1200px 900px at 50% 20%, #1a0f46 0%, var(--bg0) 58%, #05030d 100%);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
        overscroll-behavior: none;
        overflow: hidden;
      }

      .wrap {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      .stage {
        position: relative;
        width: min(100vw, 520px);
        height: 100vh;
        max-height: 100vh;
        display: grid;
        place-items: center;
      }

      canvas {
        display: block;
        width: 0;
        height: 0;
        touch-action: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        image-rendering: auto;
      }

      .hud {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        z-index: 5;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        pointer-events: none;
      }

      .hud-left {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        pointer-events: none;
        display: inline-flex;
        align-items: baseline;
        gap: 8px;
        padding: 10px 12px;
        border-radius: 999px;
        background: var(--panel);
        border: 1px solid var(--stroke);
        box-shadow: 0 0 14px rgba(57, 246, 255, 0.12);
        backdrop-filter: blur(6px);
        font-variant-numeric: tabular-nums;
      }

      .pill b {
        letter-spacing: 0.06em;
        text-transform: uppercase;
        font-size: 12px;
        color: rgba(240, 248, 255, 0.75);
      }

      .pill span {
        font-weight: 800;
        color: rgba(240, 248, 255, 0.95);
      }

      .btn {
        pointer-events: auto;
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: var(--panel2);
        color: rgba(240, 248, 255, 0.92);
        padding: 10px 12px;
        border-radius: 999px;
        font: inherit;
        cursor: pointer;
        box-shadow: 0 0 14px rgba(255, 52, 210, 0.10);
        transition: transform 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease;
      }

      .btn:active { transform: translateY(1px); }
      .btn:focus-visible { outline: 2px solid rgba(57, 246, 255, 0.75); outline-offset: 2px; }

      .overlay {
        position: absolute;
        inset: 0;
        z-index: 10;
        display: none;
        place-items: center;
        padding: 22px 16px;
        background:
          radial-gradient(700px 520px at 50% 25%, rgba(57, 246, 255, 0.10), transparent 55%),
          radial-gradient(700px 520px at 50% 75%, rgba(255, 52, 210, 0.10), transparent 55%),
          rgba(0, 0, 0, 0.22);
        backdrop-filter: blur(6px);
      }

      .overlay.show { display: grid; }

      .card {
        width: min(520px, 92vw);
        border-radius: 18px;
        border: 1px solid rgba(57, 246, 255, 0.20);
        background: rgba(5, 6, 14, 0.62);
        box-shadow:
          0 12px 50px rgba(0, 0, 0, 0.55),
          0 0 24px rgba(57, 246, 255, 0.12);
        padding: 18px 16px;
        text-align: center;
      }

      .title {
        margin: 0 0 8px;
        font-size: 28px;
        letter-spacing: 0.02em;
        text-shadow: 0 0 18px rgba(57, 246, 255, 0.30), 0 0 22px rgba(255, 52, 210, 0.14);
      }

      .subtitle {
        margin: 0 0 14px;
        color: var(--muted);
        font-size: 14px;
        line-height: 1.35;
      }

      .hint {
        margin: 10px 0 0;
        color: rgba(240, 248, 255, 0.70);
        font-size: 12px;
      }

      .big {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-top: 10px;
        padding: 14px 18px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: linear-gradient(180deg, rgba(57, 246, 255, 0.16), rgba(255, 52, 210, 0.10));
        color: rgba(240, 248, 255, 0.95);
        font-weight: 900;
        letter-spacing: 0.02em;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        box-shadow:
          0 0 0 1px rgba(57, 246, 255, 0.12) inset,
          0 0 18px rgba(57, 246, 255, 0.16),
          0 0 22px rgba(255, 52, 210, 0.10);
        transition: transform 0.10s ease;
      }

      .big:active { transform: translateY(1px) scale(0.99); }

      .row {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .tiny {
        font-size: 12px;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(0, 0, 0, 0.18);
        color: rgba(240, 248, 255, 0.84);
        cursor: pointer;
      }

      .tiny strong { color: rgba(240, 248, 255, 0.96); }

      .footer {
        margin-top: 12px;
        font-size: 12px;
        color: rgba(240, 248, 255, 0.65);
      }

      @media (max-width: 420px) {
        .title { font-size: 24px; }
        .pill { padding: 9px 11px; }
        .pill b { font-size: 11px; }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="stage" id="stage">
        <canvas id="game" aria-label="Neon Rage Dodge game canvas"></canvas>

        <div class="hud" aria-hidden="true">
          <div class="hud-left">
            <div class="pill"><b>Score</b><span id="hudScore">0</span></div>
            <div class="pill"><b>Best</b><span id="hudBest">0</span></div>
            <div class="pill"><b>Streak</b><span id="hudStreak">0</span></div>
          </div>
          <button class="btn" id="soundBtn" type="button" aria-label="Toggle sound">Sound: ON</button>
        </div>

        <div class="overlay show" id="overlayStart" role="dialog" aria-label="Start screen">
          <div class="card">
            <h1 class="title">Neon Rage Dodge</h1>
            <p class="subtitle">
              Super snappy 2‑lane reaction dodger. Survive. Stack streaks. Farm “SICK”.
            </p>
            <div class="row">
              <button class="tiny" id="dailyBtn" type="button" aria-label="Toggle daily seed mode">
                Daily: <strong id="dailyState">OFF</strong>
              </button>
              <span class="tiny" id="seedBadge" style="display:none;">Seed: <strong id="seedText">—</strong></span>
            </div>
            <div class="big" id="playBtn" role="button" tabindex="0">Tap to Play</div>
            <p class="hint">Tap / click / Space = toggle lanes. No dragging.</p>
            <div class="footer">Tip: “SICK” triggers on late dodges (near‑miss).</div>
          </div>
        </div>

        <div class="overlay" id="overlayOver" role="dialog" aria-label="Game over screen">
          <div class="card">
            <h2 class="title" style="margin-bottom:6px;">Game Over</h2>
            <p class="subtitle" id="tauntText" style="margin-top:0;">One more.</p>
            <p class="subtitle" style="margin: 10px 0 0;">
              Final: <strong id="finalScore">0</strong> · Best: <strong id="finalBest">0</strong>
            </p>
            <div class="big" id="againBtn" role="button" tabindex="0">Play Again</div>
            <p class="hint">Tap / Space instantly restarts.</p>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        // ========= Config =========
        const LOGICAL_W = 720;
        const LOGICAL_H = 1280;
        const BEST_KEY = "neon-rage-dodge-best";

        const TAUNTS = [
          "Skill issue.",
          "One more.",
          "Close…",
          "Not bad.",
          "You blinked.",
          "Hands faster.",
          "Again. Again.",
          "You had that.",
          "Rage -> Retry.",
        ];

        const canvas = document.getElementById("game");
        const stage = document.getElementById("stage");
        const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });
        if (!ctx) throw new Error("Canvas 2D not supported.");

        const hudScore = document.getElementById("hudScore");
        const hudBest = document.getElementById("hudBest");
        const hudStreak = document.getElementById("hudStreak");
        const soundBtn = document.getElementById("soundBtn");

        const overlayStart = document.getElementById("overlayStart");
        const overlayOver = document.getElementById("overlayOver");
        const playBtn = document.getElementById("playBtn");
        const againBtn = document.getElementById("againBtn");
        const finalScoreEl = document.getElementById("finalScore");
        const finalBestEl = document.getElementById("finalBest");
        const tauntText = document.getElementById("tauntText");

        const dailyBtn = document.getElementById("dailyBtn");
        const dailyState = document.getElementById("dailyState");
        const seedBadge = document.getElementById("seedBadge");
        const seedText = document.getElementById("seedText");

        // ========= Resize / fixed logical resolution =========
        let dpr = 1;
        function resize() {
          dpr = Math.max(1, Math.min(2, Math.floor(window.devicePixelRatio || 1)));
          canvas.width = LOGICAL_W * dpr;
          canvas.height = LOGICAL_H * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          const r = stage.getBoundingClientRect();
          const scale = Math.min(r.width / LOGICAL_W, r.height / LOGICAL_H);
          canvas.style.width = `${Math.floor(LOGICAL_W * scale)}px`;
          canvas.style.height = `${Math.floor(LOGICAL_H * scale)}px`;
        }
        window.addEventListener("resize", resize, { passive: true });
        resize();

        // ========= RNG (daily seed optional) =========
        function yyyymmdd(d = new Date()) {
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, "0");
          const day = String(d.getDate()).padStart(2, "0");
          return `${y}${m}${day}`;
        }

        function hashStringToU32(str) {
          // FNV-1a-ish
          let h = 2166136261 >>> 0;
          for (let i = 0; i < str.length; i++) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return h >>> 0;
        }

        function makeXorshift32(seedU32) {
          let x = (seedU32 >>> 0) || 0x12345678;
          return {
            nextU32() {
              x ^= (x << 13) >>> 0;
              x ^= (x >>> 17) >>> 0;
              x ^= (x << 5) >>> 0;
              return (x >>> 0);
            },
            next() {
              return this.nextU32() / 4294967296;
            },
            range(min, max) {
              return min + (max - min) * this.next();
            },
            int(min, maxInclusive) {
              return Math.floor(this.range(min, maxInclusive + 1));
            },
            pick(arr) {
              return arr[Math.floor(this.next() * arr.length)];
            },
          };
        }

        let dailyMode = false;
        let seedStr = yyyymmdd();
        let rng = makeXorshift32((crypto?.getRandomValues ? crypto.getRandomValues(new Uint32Array(1))[0] : (Math.random() * 2 ** 32) >>> 0));
        function applySeedMode() {
          dailyState.textContent = dailyMode ? "ON" : "OFF";
          if (dailyMode) {
            seedStr = yyyymmdd();
            seedText.textContent = seedStr;
            seedBadge.style.display = "";
            rng = makeXorshift32(hashStringToU32(seedStr));
          } else {
            seedBadge.style.display = "none";
            rng = makeXorshift32((crypto?.getRandomValues ? crypto.getRandomValues(new Uint32Array(1))[0] : (Math.random() * 2 ** 32) >>> 0));
          }
        }
        applySeedMode();

        // ========= Audio (optional, user-gesture safe) =========
        let soundOn = true;
        let audioCtx = null;
        let master = null;

        function ensureAudioFromGesture() {
          if (!soundOn) return;
          if (audioCtx) return;
          const AC = window.AudioContext || window.webkitAudioContext;
          audioCtx = new AC();
          master = audioCtx.createGain();
          master.gain.value = 0.55;
          master.connect(audioCtx.destination);
        }

        function blip(freq, durMs, type = "square", gain = 0.12) {
          if (!soundOn) return;
          if (!audioCtx || !master) return;
          const t = audioCtx.currentTime;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type;
          o.frequency.setValueAtTime(freq, t);
          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t + durMs / 1000);
          o.connect(g);
          g.connect(master);
          o.start(t);
          o.stop(t + durMs / 1000 + 0.03);
        }

        function updateSoundBtn() {
          soundBtn.textContent = soundOn ? "Sound: ON" : "Sound: OFF";
        }
        updateSoundBtn();

        soundBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          // Click is a valid gesture to start AudioContext if turning ON
          if (!soundOn) {
            soundOn = true;
            ensureAudioFromGesture();
            blip(880, 80, "square", 0.10);
          } else {
            blip(220, 70, "square", 0.09);
            soundOn = false;
          }
          updateSoundBtn();
        });

        // ========= Game State =========
        const state = {
          mode: "start", // start | playing | over
          t: 0,
          lastMs: 0,
          startMs: 0,
          elapsedMs: 0,
          score: 0,
          bonus: 0,
          best: 0,
          streak: 0,
          lastNearMs: 0,
          sickText: null,
          sickTimer: 0,
          flicker: 1,
          gridOffset: 0,
        };

        function loadBest() {
          const n = Number(localStorage.getItem(BEST_KEY));
          state.best = Number.isFinite(n) ? Math.max(0, Math.floor(n)) : 0;
          hudBest.textContent = String(state.best);
        }
        function saveBestIfNeeded(finalScore) {
          const s = Math.max(0, Math.floor(finalScore));
          if (s > state.best) {
            state.best = s;
            localStorage.setItem(BEST_KEY, String(s));
            hudBest.textContent = String(state.best);
          }
        }
        loadBest();

        const player = {
          lane: 0, // 0 left, 1 right
          x: LOGICAL_W * 0.34,
          y: LOGICAL_H * 0.86,
          r: 18,
          pulse: 0,
          toggleFlash: 0,
        };

        const lanes = {
          leftX: LOGICAL_W * 0.34,
          rightX: LOGICAL_W * 0.66,
          railInset: 90,
        };

        function laneX(lane) {
          return lane === 0 ? lanes.leftX : lanes.rightX;
        }

        const obstacles = [];
        let spawnAt = 0;
        const spawnQueue = []; // ms offsets relative to now

        // Particles (pooled)
        const particles = [];
        const MAX_PARTICLES = 220;
        function spawnParticles(x, y, count, baseSpeed, lifeMs, colorA, colorB) {
          for (let i = 0; i < count; i++) {
            if (particles.length >= MAX_PARTICLES) break;
            const a = rng.range(0, Math.PI * 2);
            const sp = baseSpeed * rng.range(0.35, 1.0);
            particles.push({
              x,
              y,
              vx: Math.cos(a) * sp,
              vy: Math.sin(a) * sp,
              life: lifeMs,
              maxLife: lifeMs,
              size: rng.range(2, 6),
              c0: colorA,
              c1: colorB,
            });
          }
        }

        function resetRun(nowMs) {
          state.startMs = nowMs;
          state.elapsedMs = 0;
          state.score = 0;
          state.bonus = 0;
          state.streak = 0;
          state.lastNearMs = 0;
          state.sickText = null;
          state.sickTimer = 0;
          player.lane = 0;
          player.x = laneX(player.lane);
          player.toggleFlash = 0;
          obstacles.length = 0;
          particles.length = 0;
          spawnAt = nowMs + 700;
          spawnQueue.length = 0;
        }

        // ========= Difficulty ramp =========
        function difficultyAt(elapsedMs) {
          const t = Math.max(0, elapsedMs / 1000);
          // first ~12s feel fair; then ramp
          const speed = 640 + t * 18 + Math.max(0, t - 12) * 9; // px/s
          const interval = Math.max(260, 880 - t * 9 - Math.max(0, t - 12) * 7); // ms
          const size = 78 + Math.min(24, t * 0.7);
          return { t, speed, interval, size };
        }

        function obstacleRadius(o) {
          if (o.kind === "circle") return o.r;
          // rect approximate radius
          return Math.sqrt((o.w * 0.5) ** 2 + (o.h * 0.5) ** 2);
        }

        function obstacleThreatWindowY() {
          return {
            start: player.y - 240,
            end: player.y - 46,
          };
        }

        function laneWouldBlockBoth(lane, y, minGapY) {
          // If the *other* lane already has an obstacle near y, then spawning on this lane near y would block both lanes.
          const otherLane = lane === 0 ? 1 : 0;
          for (let i = 0; i < obstacles.length; i++) {
            const o = obstacles[i];
            if (o.lane !== otherLane) continue;
            if (Math.abs(o.y - y) < minGapY) return true;
          }
          return false;
        }

        function pickLaneSpawn(y) {
          // bias toward making player move, but keep it fair
          const bias = rng.next() < 0.58;
          let lane = bias ? player.lane : (player.lane ^ 1);
          // Avoid spawning a "both lanes blocked" situation near the player's zone
          if (laneWouldBlockBoth(lane, y, 140)) lane ^= 1;
          // Still blocked? (rare) then return null to skip this spawn.
          if (laneWouldBlockBoth(lane, y, 140)) return null;
          return lane;
        }

        function spawnOne(nowMs, forcedLane = null) {
          const d = difficultyAt(state.elapsedMs);
          const y = -110;
          const lane = forcedLane != null ? forcedLane : pickLaneSpawn(player.y - 520);
          if (lane == null) return false;

          const kind = rng.next() < 0.55 ? "rect" : "circle";
          const base = d.size * rng.range(0.92, 1.12);
          const wobble = rng.range(-18, 18); // subtle drift within lane
          const huePick = rng.next();
          const color = huePick < 0.5 ? "cyan" : (huePick < 0.85 ? "magenta" : "purple");
          const o = {
            kind: kind === "rect" ? "rect" : "circle",
            lane,
            x: laneX(lane) + wobble,
            y,
            vy: d.speed * rng.range(0.94, 1.05),
            w: kind === "rect" ? base * rng.range(0.85, 1.1) : 0,
            h: kind === "rect" ? base * rng.range(0.85, 1.1) : 0,
            r: kind === "circle" ? (base * 0.52) : 0,
            spin: rng.range(-1.6, 1.6),
            rot: rng.range(0, Math.PI * 2),
            color,
            threatened: false,
            nearEligible: false,
            nearAwarded: false,
          };
          obstacles.push(o);
          return true;
        }

        function schedulePattern(nowMs) {
          // Patterns: single, double, fake-out rhythm
          // We schedule offsets so spawns feel snappy but readable.
          const t = state.elapsedMs / 1000;
          const pDouble = Math.min(0.28, 0.10 + Math.max(0, t - 8) * 0.004);
          const pFake = Math.min(0.22, 0.06 + Math.max(0, t - 12) * 0.004);

          const r = rng.next();
          if (r < pFake) {
            // fake-out: one, beat gap, then double
            spawnQueue.push(0);
            spawnQueue.push(320);
            spawnQueue.push(470);
          } else if (r < pFake + pDouble) {
            // double: two quick spawns
            spawnQueue.push(0);
            spawnQueue.push(180);
          } else {
            spawnQueue.push(0);
          }
        }

        // ========= Input =========
        let seenFirstGesture = false;

        function toggleLane(nowMs) {
          if (state.mode !== "playing") return;
          player.lane ^= 1;
          player.x = laneX(player.lane);
          player.toggleFlash = 1;

          // mark near-miss eligibility for threats you dodged late
          const win = obstacleThreatWindowY();
          const oldLane = player.lane ^ 1;
          for (let i = 0; i < obstacles.length; i++) {
            const o = obstacles[i];
            if (o.lane !== oldLane) continue;
            if (!o.threatened) continue;
            if (o.nearEligible) continue;
            if (o.y > win.start && o.y < win.end) {
              o.nearEligible = true;
            }
          }

          // audio
          blip(880, 60, "square", 0.10);
        }

        function onAnyGesture(e) {
          // Don't treat UI button taps as lane toggles / start taps.
          const t = e && e.target;
          if (t && typeof t.closest === "function" && t.closest("button")) return;

          // prevent browser from scrolling/pulling-to-refresh during play
          if (e && e.cancelable) e.preventDefault();

          if (!seenFirstGesture) {
            seenFirstGesture = true;
            ensureAudioFromGesture();
          }

          const nowMs = performance.now();
          if (state.mode === "start") {
            startGame(nowMs);
            return;
          }
          if (state.mode === "over") {
            startGame(nowMs);
            return;
          }
          toggleLane(nowMs);
        }

        window.addEventListener("pointerdown", onAnyGesture, { passive: false });
        window.addEventListener("keydown", (e) => {
          if (e.code === "Space" && !e.repeat) {
            e.preventDefault();
            onAnyGesture(e);
          }
        }, { passive: false });

        playBtn.addEventListener("click", (e) => onAnyGesture(e));
        againBtn.addEventListener("click", (e) => onAnyGesture(e));
        playBtn.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") onAnyGesture(e); });
        againBtn.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") onAnyGesture(e); });

        dailyBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          dailyMode = !dailyMode;
          applySeedMode();
          blip(dailyMode ? 740 : 330, 70, "square", 0.09);
        });

        // ========= Start / Over =========
        function startGame(nowMs) {
          overlayStart.classList.remove("show");
          overlayOver.classList.remove("show");
          state.mode = "playing";
          resetRun(nowMs);
          // tiny start ping
          blip(660, 65, "square", 0.10);
        }

        function endGame(nowMs) {
          state.mode = "over";
          saveBestIfNeeded(state.score);
          finalScoreEl.textContent = String(Math.floor(state.score));
          finalBestEl.textContent = String(state.best);
          tauntText.textContent = rng.pick(TAUNTS);
          overlayOver.classList.add("show");
          // death sound
          blip(110, 220, "sawtooth", 0.12);
          blip(55, 260, "square", 0.06);
          // death burst
          spawnParticles(player.x, player.y, 52, 820, 620, "rgba(255,52,210,0.95)", "rgba(57,246,255,0.9)");
        }

        // ========= Render helpers =========
        function clear() {
          ctx.fillStyle = "#070513";
          ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);
        }

        function drawBackground(nowMs) {
          const t = nowMs * 0.001;
          const flick = 0.98 + (rng.next() * 0.04);
          state.flicker = state.flicker * 0.88 + flick * 0.12;

          // gradient wash
          const g = ctx.createLinearGradient(0, 0, 0, LOGICAL_H);
          g.addColorStop(0, "#160a43");
          g.addColorStop(0.55, "#070513");
          g.addColorStop(1, "#04020b");
          ctx.globalAlpha = 1;
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

          // moving grid (subtle)
          const gridY = (t * 60) % 60;
          ctx.save();
          ctx.globalAlpha = 0.18;
          ctx.strokeStyle = "rgba(57,246,255,0.16)";
          ctx.lineWidth = 1;
          for (let y = -60; y < LOGICAL_H + 60; y += 60) {
            const yy = y + gridY;
            ctx.beginPath();
            ctx.moveTo(0, yy);
            ctx.lineTo(LOGICAL_W, yy);
            ctx.stroke();
          }
          ctx.globalAlpha = 0.12;
          for (let x = 0; x <= LOGICAL_W; x += 72) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, LOGICAL_H);
            ctx.stroke();
          }
          ctx.restore();

          // scanlines (cheap)
          ctx.save();
          ctx.globalAlpha = 0.16 * state.flicker;
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          for (let y = 0; y < LOGICAL_H; y += 4) {
            ctx.fillRect(0, y, LOGICAL_W, 1);
          }
          ctx.restore();

          // vignette
          ctx.save();
          ctx.globalAlpha = 0.55;
          const vg = ctx.createRadialGradient(LOGICAL_W * 0.5, LOGICAL_H * 0.55, 180, LOGICAL_W * 0.5, LOGICAL_H * 0.55, 780);
          vg.addColorStop(0, "rgba(0,0,0,0)");
          vg.addColorStop(1, "rgba(0,0,0,0.75)");
          ctx.fillStyle = vg;
          ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);
          ctx.restore();
        }

        function drawLanes(nowMs) {
          const t = nowMs * 0.001;
          const pulse = 0.5 + 0.5 * Math.sin(t * 3.2);
          const railX0 = lanes.leftX - lanes.railInset;
          const railX1 = lanes.rightX + lanes.railInset;

          ctx.save();
          ctx.globalAlpha = 0.50;
          ctx.lineWidth = 3;
          ctx.strokeStyle = `rgba(57,246,255,${0.22 + 0.08 * pulse})`;
          ctx.shadowColor = "rgba(57,246,255,0.35)";
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.moveTo(railX0, 0);
          ctx.lineTo(railX0, LOGICAL_H);
          ctx.moveTo(railX1, 0);
          ctx.lineTo(railX1, LOGICAL_H);
          ctx.stroke();
          ctx.restore();

          // pulsing hit-zone ring near player
          ctx.save();
          ctx.globalAlpha = 0.7;
          const r = 54 + 8 * pulse;
          ctx.lineWidth = 3;
          ctx.strokeStyle = `rgba(255,52,210,${0.25 + 0.12 * pulse})`;
          ctx.shadowColor = "rgba(255,52,210,0.25)";
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.arc(player.x, player.y, r, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        function neonColor(name) {
          if (name === "magenta") return { core: "#ff34d2", glow: "rgba(255,52,210,0.65)" };
          if (name === "purple") return { core: "#8b5cff", glow: "rgba(139,92,255,0.55)" };
          return { core: "#39f6ff", glow: "rgba(57,246,255,0.65)" };
        }

        function drawPlayer() {
          ctx.save();
          ctx.globalAlpha = 1;
          const t = state.t;
          player.pulse = player.pulse * 0.86 + (0.5 + 0.5 * Math.sin(t * 4.5)) * 0.14;
          player.toggleFlash *= 0.86;

          const glow = 10 + 10 * player.pulse + 18 * player.toggleFlash;
          ctx.shadowColor = "rgba(57,246,255,0.65)";
          ctx.shadowBlur = glow;

          // ship core
          ctx.fillStyle = "#39f6ff";
          ctx.beginPath();
          ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
          ctx.fill();

          // tiny direction notch
          ctx.shadowBlur = 0;
          ctx.fillStyle = "rgba(255,255,255,0.92)";
          ctx.beginPath();
          ctx.arc(player.x + player.r * 0.45, player.y - player.r * 0.20, 3.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        function drawObstacle(o) {
          const c = neonColor(o.color);
          ctx.save();
          ctx.translate(o.x, o.y);
          ctx.rotate(o.rot);
          ctx.shadowColor = c.glow;
          ctx.shadowBlur = 12;
          ctx.globalAlpha = 1;
          ctx.lineWidth = 4;
          ctx.strokeStyle = c.core;
          ctx.fillStyle = "rgba(0,0,0,0.0)";

          if (o.kind === "circle") {
            ctx.beginPath();
            ctx.arc(0, 0, o.r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = c.core;
            ctx.beginPath();
            ctx.arc(0, 0, o.r * 0.86, 0, Math.PI * 2);
            ctx.fill();
          } else {
            const w = o.w, h = o.h;
            ctx.strokeRect(-w * 0.5, -h * 0.5, w, h);
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = c.core;
            ctx.fillRect(-w * 0.44, -h * 0.44, w * 0.88, h * 0.88);
          }
          ctx.restore();
        }

        function drawParticles() {
          if (particles.length === 0) return;
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            const a = Math.max(0, p.life / p.maxLife);
            const col = a > 0.5 ? p.c0 : p.c1;
            ctx.globalAlpha = 0.85 * a;
            ctx.fillStyle = col;
            ctx.shadowColor = col;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (0.7 + 0.5 * (1 - a)), 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
          ctx.globalCompositeOperation = "source-over";
        }

        function drawSickText() {
          if (!state.sickText || state.sickTimer <= 0) return;
          const a = Math.min(1, state.sickTimer / 420);
          ctx.save();
          ctx.globalAlpha = 0.9 * a;
          ctx.font = "900 64px system-ui, -apple-system, Segoe UI, Roboto";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "rgba(255,52,210,0.7)";
          ctx.shadowBlur = 18;
          ctx.fillStyle = "#ff34d2";
          ctx.fillText(state.sickText, LOGICAL_W * 0.5, LOGICAL_H * 0.22);
          ctx.restore();
        }

        // ========= Update loop =========
        function update(nowMs) {
          const dtMs = Math.min(34, Math.max(0, nowMs - state.lastMs));
          state.lastMs = nowMs;
          state.t = nowMs * 0.001;

          if (state.mode === "playing") {
            state.elapsedMs = nowMs - state.startMs;

            // score: time survived + bonuses
            const timePoints = Math.floor(state.elapsedMs / 10); // 100 pts/sec
            state.score = timePoints + state.bonus;

            // streak decay if you stop getting near-misses
            if (state.streak > 0 && state.lastNearMs > 0 && (nowMs - state.lastNearMs) > 2500) {
              state.streak = 0;
            }

            // spawn scheduler
            const d = difficultyAt(state.elapsedMs);
            if (spawnQueue.length === 0 && nowMs >= spawnAt) {
              schedulePattern(nowMs);
              spawnAt = nowMs + d.interval;
            }
            while (spawnQueue.length && spawnQueue[0] <= 0) {
              spawnQueue.shift();
              spawnOne(nowMs);
            }
            for (let i = 0; i < spawnQueue.length; i++) spawnQueue[i] -= dtMs;

            // update obstacles
            const collPad = 2;
            const collisionSlack = -6; // slightly forgiving hitbox
            const win = obstacleThreatWindowY();

            for (let i = obstacles.length - 1; i >= 0; i--) {
              const o = obstacles[i];
              o.y += (o.vy * dtMs) / 1000;
              o.rot += o.spin * (dtMs / 1000);

              // mark threatened if it enters player's zone while in player's lane
              if (!o.threatened && o.lane === player.lane && o.y > win.start) {
                o.threatened = true;
              }

              // collision (approx circle)
              const ox = o.x;
              const oy = o.y;
              const pr = player.r;
              const or = obstacleRadius(o) - collPad;
              const dx = ox - player.x;
              const dy = oy - player.y;
              const dist2 = dx * dx + dy * dy;
              const hit = dist2 <= (pr + or + collisionSlack) * (pr + or + collisionSlack);
              if (hit) {
                endGame(nowMs);
                break;
              }

              // near miss award: late dodge only
              if (!o.nearAwarded && o.nearEligible && o.y > (player.y + obstacleRadius(o))) {
                o.nearAwarded = true;
                state.lastNearMs = nowMs;
                state.streak += 1;
                const streakMult = 1 + Math.min(1.2, state.streak * 0.10);
                const add = Math.floor(220 * streakMult);
                state.bonus += add;
                state.sickText = "SICK";
                state.sickTimer = 520;
                blip(990, 70, "square", 0.11);
                spawnParticles(o.x, player.y - 40, 18, 520, 520, "rgba(57,246,255,0.95)", "rgba(255,52,210,0.9)");
              }

              // cleanup
              if (o.y > LOGICAL_H + 180) obstacles.splice(i, 1);
            }

            // update particles
            for (let i = particles.length - 1; i >= 0; i--) {
              const p = particles[i];
              p.life -= dtMs;
              p.vx *= 0.985;
              p.vy = p.vy * 0.985 + 30 * (dtMs / 1000);
              p.x += (p.vx * dtMs) / 1000;
              p.y += (p.vy * dtMs) / 1000;
              if (p.life <= 0) particles.splice(i, 1);
            }

            // sick text timer
            if (state.sickTimer > 0) state.sickTimer -= dtMs;
          } else {
            // idle background drift
            for (let i = particles.length - 1; i >= 0; i--) {
              const p = particles[i];
              p.life -= dtMs;
              p.vx *= 0.99;
              p.vy *= 0.99;
              p.x += (p.vx * dtMs) / 1000;
              p.y += (p.vy * dtMs) / 1000;
              if (p.life <= 0) particles.splice(i, 1);
            }
            if (state.sickTimer > 0) state.sickTimer -= dtMs;
          }

          // HUD
          hudScore.textContent = String(Math.floor(state.score));
          hudStreak.textContent = String(state.streak);
        }

        // ========= Draw loop =========
        function draw(nowMs) {
          drawBackground(nowMs);
          drawLanes(nowMs);

          // obstacles
          for (let i = 0; i < obstacles.length; i++) drawObstacle(obstacles[i]);

          // player
          drawPlayer();

          // particles & text
          drawParticles();
          drawSickText();

          // subtle CRT noise flicker overlay
          ctx.save();
          ctx.globalAlpha = 0.05 * state.flicker;
          ctx.fillStyle = "rgba(255,255,255,0.6)";
          const n = 22;
          for (let i = 0; i < n; i++) {
            const x = rng.range(0, LOGICAL_W);
            const y = rng.range(0, LOGICAL_H);
            ctx.fillRect(x, y, rng.range(20, 80), 1);
          }
          ctx.restore();
        }

        function frame(nowMs) {
          update(nowMs);
          draw(nowMs);
          requestAnimationFrame(frame);
        }

        // ========= Boot =========
        function boot() {
          state.lastMs = performance.now();
          // ambient start particles
          spawnParticles(LOGICAL_W * 0.5, LOGICAL_H * 0.35, 18, 260, 1200, "rgba(57,246,255,0.35)", "rgba(255,52,210,0.28)");
          overlayStart.classList.add("show");
          overlayOver.classList.remove("show");
          requestAnimationFrame(frame);
        }

        boot();
      })();
    </script>
  </body>
</html>
