<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Neon Rift Split</title>
  <style>
    :root{
      --bg:#070712;
      --panel:rgba(5,8,22,.85);
      --cyan:#2df4ff;
      --pink:#ff5fe6;
      --violet:#a76aff;
      --text:#eaf7ff;
      --dim:rgba(150,205,255,.22);
    }

    html,body{
      margin:0;height:100%;overflow:hidden;
      background:radial-gradient(circle at top,#111739 0%,#080a1d 45%,#04030d 100%);
      color:var(--text);
      font-family:"Courier New", Courier, monospace;
      touch-action:none;
      user-select:none;-webkit-user-select:none;
    }

    #app{
      position:fixed;inset:0;
      display:flex;align-items:center;justify-content:center;
      padding:10px;box-sizing:border-box;
    }

    #gameWrap{
      position:relative;
      width:900px;height:600px;
      border:1px solid rgba(88,151,255,.35);
      box-shadow:0 0 45px rgba(62,132,255,.25), inset 0 0 35px rgba(80,18,180,.18);
      border-radius:10px;
      overflow:hidden;
      background:#060713;
    }

    #gameCanvas{
      position:absolute;inset:0;
      width:100%;height:100%;
      display:block;

      /* ✅ Start/GameOver overlay needs clicks: canvas must NOT steal taps */
      pointer-events:none;
    }

    #scanlines,#crtFlicker{
      position:absolute;inset:0;
      pointer-events:none;z-index:6;
    }
    #scanlines{
      background:linear-gradient(to bottom, rgba(255,255,255,.02) 50%, rgba(0,0,0,.12) 50%);
      background-size:100% 4px;
      opacity:.45;
    }
    @keyframes flicker{
      0%{opacity:.06} 19%{opacity:.11} 20%{opacity:.03}
      41%{opacity:.12} 42%{opacity:.05} 100%{opacity:.08}
    }
    #crtFlicker{
      background:rgba(14,16,22,.45);
      animation:flicker .12s infinite;
    }

    .overlay{
      position:absolute;inset:0;
      z-index:10;
      display:flex;align-items:center;justify-content:center;
      flex-direction:column;gap:10px;text-align:center;
      padding:24px;box-sizing:border-box;
      background:rgba(2,2,8,.82);
      backdrop-filter:blur(4px);

      /* ✅ overlays must be clickable */
      pointer-events:auto;
    }
    .overlay.hidden{display:none;}

    h1{
      margin:0 0 8px;
      font-size:clamp(30px,6vw,52px);
      letter-spacing:2px;
      text-transform:uppercase;
      color:#d9f7ff;
      text-shadow:0 0 14px rgba(45,244,255,.6), 0 0 26px rgba(255,95,230,.4);
    }

    p{margin:2px 0;opacity:.88;line-height:1.35;max-width:700px;}
    .muted{opacity:.62;font-size:13px;}

    .panel{
      border:1px solid var(--dim);
      background:var(--panel);
      border-radius:10px;
      padding:14px 18px;
      box-shadow:0 0 20px rgba(50,100,255,.2);
      max-width:760px;
    }

    .btn-row{
      display:flex;flex-wrap:wrap;
      align-items:center;justify-content:center;
      gap:10px;margin-top:8px;
    }

    button{
      border:1px solid rgba(110,205,255,.6);
      background:rgba(5,18,35,.9);
      color:#dff7ff;
      padding:10px 14px;
      border-radius:999px;
      font-family:inherit;
      cursor:pointer;
      font-size:14px;
      transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease;
      box-shadow:0 0 14px rgba(45,244,255,.25);
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
    }
    button:hover{
      transform:translateY(-1px);
      border-color:rgba(255,120,230,.9);
      box-shadow:0 0 18px rgba(255,120,230,.38);
    }

    #startBtn,#restartBtn{
      font-size:16px;letter-spacing:.7px;
      padding:11px 20px;border-radius:10px;
    }

    #pulseBtn{
      position:absolute;
      z-index:9;
      bottom:12px;left:50%;
      transform:translateX(-50%);
      padding:10px 16px;
      border-radius:999px;
      border:1px solid rgba(190,120,255,.9);
      background:rgba(48,10,90,.72);
      color:#f2e7ff;
      box-shadow:0 0 18px rgba(200,105,255,.45);
      display:none;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
    }
    #pulseBtn.show{display:inline-block;}
    #pulseBtn.ready{
      border-color:rgba(90,255,210,.9);
      box-shadow:0 0 20px rgba(90,255,210,.52);
      background:rgba(6,80,72,.78);
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="gameWrap">
      <canvas id="gameCanvas" aria-label="Neon Rift Split game canvas"></canvas>
      <div id="scanlines"></div>
      <div id="crtFlicker"></div>

      <button id="pulseBtn" type="button">RIFT PULSE</button>

      <section id="startOverlay" class="overlay">
        <h1>Neon Rift Split</h1>
        <div class="panel">
          <p>Control two avatars at once. If either dies, the run ends.</p>
          <p>Desktop: Left = WASD, Right = Arrow Keys, Space = Rift Pulse (swap positions).</p>
          <p>Mobile: Left/Right half joystick. Double tap your half to dash.</p>
          <p class="muted">Survive telegraphed hazards. Near-miss dodges grant bonus score.</p>
        </div>
        <div class="btn-row">
          <button id="startBtn" type="button">Start Run</button>
          <button id="soundBtn" type="button">Sound: ON</button>
        </div>
        <p id="startBestLine" class="muted"></p>
      </section>

      <section id="gameOverOverlay" class="overlay hidden">
        <h1>Game Over</h1>
        <div class="panel">
          <p id="resultTime">Time: 0.0s</p>
          <p id="resultScore">Score: 0</p>
          <p id="resultBest">Best: 0</p>
        </div>
        <div class="btn-row">
          <button id="restartBtn" type="button">Restart</button>
          <button id="soundBtnGameOver" type="button">Sound: ON</button>
        </div>
      </section>
    </div>
  </div>

  <script>
  (() => {
    "use strict";

    const WORLD_W = 900;
    const WORLD_H = 600;
    const ARENA_W = WORLD_W / 2;
    const HUD_H = 52;
    const PLAY_TOP = HUD_H + 8;
    const PLAY_BOTTOM = WORLD_H - 12;

    const STORAGE = {
      best: "neon-rift-best",
      sound: "neon-rift-sound",
      runs: "neon-rift-total-runs",
      bestTime: "neon-rift-best-time",
    };

    const TIER_NAMES = ["SYNC","SWITCH","SURGE","OVERLOAD","RIFTED","TOXIC","MELTDOWN","VOID"];

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const gameWrap = document.getElementById("gameWrap");

    const startOverlay = document.getElementById("startOverlay");
    const gameOverOverlay = document.getElementById("gameOverOverlay");
    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");
    const soundBtn = document.getElementById("soundBtn");
    const soundBtnGameOver = document.getElementById("soundBtnGameOver");
    const pulseBtn = document.getElementById("pulseBtn");

    const resultTime = document.getElementById("resultTime");
    const resultScore = document.getElementById("resultScore");
    const resultBest = document.getElementById("resultBest");
    const startBestLine = document.getElementById("startBestLine");

    const isTouchDevice = window.matchMedia("(pointer: coarse)").matches || navigator.maxTouchPoints > 0;
    const keyState = Object.create(null);
    const pointerToSide = new Map();

    let dpr = 1;
    let audioCtx = null;
    let nextHazardId = 1;
    let lastFrame = performance.now();

    const state = {
      screen: "start",
      time: 0,
      score: 0,
      best: loadNumber(STORAGE.best, 0),
      bestTime: loadNumber(STORAGE.bestTime, 0),
      totalRuns: loadNumber(STORAGE.runs, 0),
      soundOn: loadBoolean(STORAGE.sound, true),
      spawnTimer: 0.9,
      pulseCooldown: 0,
      hazards: [],
      particles: [],
      floatTexts: [],
      gridOffset: 0,
      difficultyTier: 1,
    };

    const players = [createPlayer(0), createPlayer(1)];
    const joysticks = [createJoystick(), createJoystick()];

    function setCanvasInteractive(on){
      canvas.style.pointerEvents = on ? "auto" : "none";
    }

    function createPlayer(arena){
      return {
        arena,
        color: arena === 0 ? "#2df4ff" : "#ff5fe6",
        radius: 10,
        x: ARENA_W * 0.5,
        y: (PLAY_TOP + PLAY_BOTTOM) * 0.5,
        vx:0, vy:0,
        lastDirX:0, lastDirY:-1,
        dashTime:0, dashCooldown:0, dashVX:0, dashVY:0,
        hitFlash:0,
      };
    }

    function createJoystick(){
      return {active:false,pointerId:null,centerX:0,centerY:0,knobX:0,knobY:0,vecX:0,vecY:0,lastTapAt:-1000};
    }

    function loadNumber(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if(raw == null) return fallback;
        const v = Number(raw);
        return Number.isFinite(v) ? v : fallback;
      }catch{ return fallback; }
    }

    function loadBoolean(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if(raw == null) return fallback;
        return raw === "1" || raw.toLowerCase() === "true";
      }catch{ return fallback; }
    }

    function saveValue(key, value){
      try{ localStorage.setItem(key, String(value)); }catch{}
    }

    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
    function rand(min,max){ return min + Math.random()*(max-min); }

    function normalize(x,y){
      const len = Math.hypot(x,y);
      if(len < 1e-6) return {x:0,y:0,len:0};
      return {x:x/len,y:y/len,len};
    }

    function worldX(arena, localX){ return arena*ARENA_W + localX; }

    // ✅ BIGGER on phone + stable
    function resizeCanvas(){
      const isMobile = window.innerWidth < 768;

      const maxW = isMobile ? window.innerWidth : window.innerWidth - 20;
      const maxH = isMobile ? window.innerHeight : window.innerHeight - 20;

      let scale = Math.min(maxW / WORLD_W, maxH / WORLD_H);

      // mobile minimum scale: prevents "tiny game"
      if(isMobile) scale = Math.max(scale, 0.62);

      const displayW = Math.max(1, Math.floor(WORLD_W * scale));
      const displayH = Math.max(1, Math.floor(WORLD_H * scale));

      gameWrap.style.width = displayW + "px";
      gameWrap.style.height = displayH + "px";

      const dprCap = isMobile ? 3 : 2;
      dpr = Math.max(1, Math.min(dprCap, window.devicePixelRatio || 1));

      canvas.width = Math.floor(WORLD_W * dpr);
      canvas.height = Math.floor(WORLD_H * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function updateSoundLabels(){
      const label = state.soundOn ? "Sound: ON" : "Sound: OFF";
      soundBtn.textContent = label;
      soundBtnGameOver.textContent = label;
    }

    function updateStartBestLine(){
      startBestLine.textContent = `Best Score ${Math.floor(state.best)} · Best Time ${state.bestTime.toFixed(1)}s`;
    }

    function updatePulseButton(){
      if(!isTouchDevice || state.screen !== "playing"){
        pulseBtn.classList.remove("show");
        return;
      }
      pulseBtn.classList.add("show");
      const cd = state.pulseCooldown;
      if(cd <= 0){
        pulseBtn.textContent = "RIFT PULSE";
        pulseBtn.classList.add("ready");
      }else{
        pulseBtn.textContent = `PULSE ${cd.toFixed(1)}s`;
        pulseBtn.classList.remove("ready");
      }
    }

    function ensureAudio(){
      if(!state.soundOn) return;
      if(audioCtx){
        if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
        return;
      }
      const AC = window.AudioContext || window.webkitAudioContext;
      if(!AC) return;
      audioCtx = new AC();
    }

    function beep(freq, durMs, type="square", volume=0.05){
      if(!state.soundOn) return;
      ensureAudio();
      if(!audioCtx) return;

      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(volume, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + durMs/1000);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t);
      o.stop(t + durMs/1000 + 0.02);
    }

    function toggleSound(){
      state.soundOn = !state.soundOn;
      saveValue(STORAGE.sound, state.soundOn ? "1" : "0");
      updateSoundLabels();
      if(state.soundOn) beep(720, 80, "triangle", 0.04);
    }

    function resetPlayers(){
      for(const p of players){
        p.x = ARENA_W * 0.5;
        p.y = (PLAY_TOP + PLAY_BOTTOM) * 0.5;
        p.vx=0;p.vy=0;
        p.lastDirX=0;p.lastDirY=-1;
        p.dashTime=0;p.dashCooldown=0;p.dashVX=0;p.dashVY=0;
        p.hitFlash=0;
      }
    }

    function resetJoysticks(){
      for(const j of joysticks){
        j.active=false; j.pointerId=null; j.vecX=0; j.vecY=0;
      }
      pointerToSide.clear();
    }

    function startRun(){
      state.screen = "playing";
      state.time = 0;
      state.score = 0;
      state.spawnTimer = 0.7;
      state.pulseCooldown = 0;
      state.gridOffset = 0;
      state.difficultyTier = 1;
      state.hazards.length = 0;
      state.particles.length = 0;
      state.floatTexts.length = 0;

      state.totalRuns += 1;
      saveValue(STORAGE.runs, Math.floor(state.totalRuns));

      resetPlayers();
      resetJoysticks();

      startOverlay.classList.add("hidden");
      gameOverOverlay.classList.add("hidden");

      // ✅ IMPORTANT: enable canvas control only while playing
      setCanvasInteractive(true);

      updatePulseButton();
      beep(540, 110, "triangle", 0.045);
    }

    function endRun(){
      if(state.screen !== "playing") return;
      state.screen = "gameover";

      const finalScore = Math.floor(state.score);
      if(finalScore > state.best){
        state.best = finalScore;
        saveValue(STORAGE.best, finalScore);
      }
      if(state.time > state.bestTime){
        state.bestTime = state.time;
        saveValue(STORAGE.bestTime, state.bestTime.toFixed(3));
      }

      resultTime.textContent = `Time: ${state.time.toFixed(1)}s`;
      resultScore.textContent = `Score: ${finalScore}`;
      resultBest.textContent = `Best: ${Math.floor(state.best)} (${state.bestTime.toFixed(1)}s)`;

      gameOverOverlay.classList.remove("hidden");
      updateStartBestLine();
      updatePulseButton();

      // ✅ IMPORTANT: disable canvas so overlay buttons are clickable
      setCanvasInteractive(false);

      beep(180, 220, "sawtooth", 0.05);
    }

    function spawnParticles(wx, wy, color, count, sMin, sMax){
      for(let i=0;i<count;i++){
        const ang = rand(0, Math.PI*2);
        const sp = rand(sMin, sMax);
        state.particles.push({x:wx,y:wy,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:rand(.3,.6),maxLife:.6,color});
      }
    }

    function pushFloatText(wx, wy, text, color){
      state.floatTexts.push({x:wx,y:wy,text,life:.9,color});
    }

    function keyboardAxis(neg,pos){
      const n = keyState[neg] ? 1 : 0;
      const p = keyState[pos] ? 1 : 0;
      return p - n;
    }

    function getInputForPlayer(side){
      let x=0,y=0;
      if(side===0){
        x += keyboardAxis("KeyA","KeyD");
        y += keyboardAxis("KeyW","KeyS");
      }else{
        x += keyboardAxis("ArrowLeft","ArrowRight");
        y += keyboardAxis("ArrowUp","ArrowDown");
      }
      x += joysticks[side].vecX;
      y += joysticks[side].vecY;
      const n = normalize(x,y);
      return {x:n.x,y:n.y};
    }

    function triggerDash(side){
      if(state.screen !== "playing") return;
      const p = players[side];
      if(p.dashCooldown > 0) return;

      const input = getInputForPlayer(side);
      let dx = input.x, dy = input.y;
      if(Math.hypot(dx,dy) < .12){ dx = p.lastDirX; dy = p.lastDirY; }
      const n = normalize(dx,dy);
      if(n.len === 0) return;

      p.dashTime = .12;
      p.dashCooldown = .95;
      p.dashVX = n.x * 650;
      p.dashVY = n.y * 650;
      spawnParticles(worldX(side,p.x), p.y, p.color, 14, 40, 160);
      beep(640 + side*80, 50, "square", 0.03);
    }

    function tryRiftPulse(){
      if(state.screen !== "playing") return;
      if(state.pulseCooldown > 0) return;

      const a = players[0], b = players[1];
      [a.x,b.x] = [b.x,a.x];
      [a.y,b.y] = [b.y,a.y];
      [a.vx,b.vx] = [b.vx,a.vx];
      [a.vy,b.vy] = [b.vy,a.vy];
      [a.lastDirX,b.lastDirX] = [b.lastDirX,a.lastDirX];
      [a.lastDirY,b.lastDirY] = [b.lastDirY,a.lastDirY];

      state.pulseCooldown = 6;
      spawnParticles(worldX(0,a.x), a.y, "#88fff9", 24, 90, 220);
      spawnParticles(worldX(1,b.x), b.y, "#ffacee", 24, 90, 220);
      pushFloatText(WORLD_W*.5 - 45, HUD_H + 18, "RIFT!", "#e6beff");
      beep(860, 120, "triangle", 0.05);
    }

    function getSpawnInterval(){ return clamp(1.3 - state.time*.015, .38, 1.3); }
    function getDartTelegraphTime(){ return clamp(.6 - state.time*.0042, .26, .6); }
    function getLaserTelegraphTime(){ return clamp(.9 - state.time*.0055, .45, .9); }
    function getDartSpeed(){ return clamp(250 + state.time*7.8, 250, 620); }

    function spawnHazards(dt){
      state.spawnTimer -= dt;
      while(state.spawnTimer <= 0){
        spawnHazardForArena(0);
        spawnHazardForArena(1);
        state.spawnTimer += getSpawnInterval();
      }
    }

    function spawnHazardForArena(arena){
      if(Math.random() < .62) spawnDart(arena);
      else spawnLaser(arena);
    }

    function spawnDart(arena){
      const target = players[arena];
      const edge = Math.floor(Math.random()*4);

      let x,y;
      if(edge===0){ x = rand(18,ARENA_W-18); y = PLAY_TOP - 18; }
      else if(edge===1){ x = ARENA_W + 18; y = rand(PLAY_TOP+12, PLAY_BOTTOM-12); }
      else if(edge===2){ x = rand(18,ARENA_W-18); y = PLAY_BOTTOM + 18; }
      else{ x = -18; y = rand(PLAY_TOP+12, PLAY_BOTTOM-12); }

      const aim = normalize((target.x + rand(-10,10)) - x, (target.y + rand(-10,10)) - y);
      const dirX = aim.len===0 ? 0 : aim.x;
      const dirY = aim.len===0 ? 1 : aim.y;

      state.hazards.push({
        id: nextHazardId++,
        type:"dart", arena,
        phase:"telegraph",
        timer:getDartTelegraphTime(),
        x,y,dirX,dirY,
        speed:getDartSpeed(),
        radius:7,
        nearMissGiven:false
      });
    }

    function spawnLaser(arena){
      const vertical = Math.random() < .5;
      const telegraph = getLaserTelegraphTime();
      const active = clamp(.34 - state.time*.0013, .22, .34);
      const thickness = clamp(12 + state.time*.17, 12, 24);

      state.hazards.push({
        id: nextHazardId++,
        type:"laser", arena,
        phase:"telegraph",
        timer:telegraph,
        vertical,
        pos: vertical ? rand(26,ARENA_W-26) : rand(PLAY_TOP+20, PLAY_BOTTOM-20),
        thickness,
        activeDuration: active,
        nearMissGiven:false
      });
    }

    function updateHazards(dt){
      for(let i=state.hazards.length-1;i>=0;i--){
        const h = state.hazards[i];
        h.timer -= dt;

        if(h.phase==="telegraph"){
          if(h.timer<=0){
            h.phase="active";
            h.timer = h.type==="dart" ? 2.2 : h.activeDuration;
          }
          continue;
        }

        if(h.phase==="active"){
          if(h.type==="dart"){
            h.x += h.dirX * h.speed * dt;
            h.y += h.dirY * h.speed * dt;
            const out = h.x < -70 || h.x > ARENA_W+70 || h.y < PLAY_TOP-80 || h.y > PLAY_BOTTOM+80;
            if(out || h.timer<=0){ h.phase="cooldown"; h.timer=.16; }
          }else{
            if(h.timer<=0){ h.phase="cooldown"; h.timer=.2; }
          }
          continue;
        }

        if(h.phase==="cooldown" && h.timer<=0){
          state.hazards.splice(i,1);
        }
      }
    }

    function rewardNearMiss(player){
      const bonus = 5;
      state.score += bonus;
      const wx = worldX(player.arena, player.x);
      pushFloatText(wx - 10, player.y - 22, `+${bonus}`, "#ffe66d");
      beep(980, 40, "triangle", 0.022);
    }

    function killPlayer(player){
      player.hitFlash = .3;
      spawnParticles(worldX(player.arena, player.x), player.y, "#ffffff", 36, 60, 240);
      endRun();
    }

    function checkCollisions(){
      for(const h of state.hazards){
        if(h.phase!=="active") continue;
        const p = players[h.arena];
        if(!p) continue;

        if(h.type==="dart"){
          const dx = p.x - h.x, dy = p.y - h.y;
          const dist = Math.hypot(dx,dy);
          const hitDist = p.radius + h.radius;

          if(dist <= hitDist){ killPlayer(p); return; }

          const nearDist = hitDist + 18;
          if(!h.nearMissGiven && dist <= nearDist && dist > hitDist + 1){
            h.nearMissGiven = true;
            rewardNearMiss(p);
          }
        }else{
          const lineDist = h.vertical ? Math.abs(p.x - h.pos) : Math.abs(p.y - h.pos);
          const hitDist = p.radius + h.thickness * .5;

          if(lineDist <= hitDist){ killPlayer(p); return; }

          const nearDist = hitDist + 20;
          if(!h.nearMissGiven && lineDist <= nearDist && lineDist > hitDist + 1){
            h.nearMissGiven = true;
            rewardNearMiss(p);
          }
        }
      }
    }

    function keepPlayerInArena(p){
      const minX = p.radius + 8;
      const maxX = ARENA_W - p.radius - 8;
      const minY = PLAY_TOP + p.radius;
      const maxY = PLAY_BOTTOM - p.radius;

      if(p.x < minX){ p.x=minX; p.vx=0; }
      else if(p.x > maxX){ p.x=maxX; p.vx=0; }
      if(p.y < minY){ p.y=minY; p.vy=0; }
      else if(p.y > maxY){ p.y=maxY; p.vy=0; }
    }

    function updatePlayers(dt){
      const acceleration = 920;
      const friction = Math.exp(-6.2*dt);
      const maxSpeed = 255;

      for(let side=0; side<players.length; side++){
        const p = players[side];
        const input = getInputForPlayer(side);
        if(Math.hypot(input.x,input.y) > .08){
          p.lastDirX = input.x; p.lastDirY = input.y;
        }

        p.dashCooldown = Math.max(0, p.dashCooldown - dt);
        p.hitFlash = Math.max(0, p.hitFlash - dt);

        p.vx += input.x * acceleration * dt;
        p.vy += input.y * acceleration * dt;

        p.vx *= friction; p.vy *= friction;

        const sp = Math.hypot(p.vx,p.vy);
        if(sp > maxSpeed){
          p.vx = (p.vx/sp)*maxSpeed;
          p.vy = (p.vy/sp)*maxSpeed;
        }

        if(p.dashTime > 0){
          p.dashTime -= dt;
          p.x += p.dashVX*dt;
          p.y += p.dashVY*dt;
          p.dashVX *= Math.exp(-11*dt);
          p.dashVY *= Math.exp(-11*dt);
        }else{
          p.x += p.vx*dt;
          p.y += p.vy*dt;
        }

        keepPlayerInArena(p);
      }
    }

    function updateParticles(dt){
      for(let i=state.particles.length-1;i>=0;i--){
        const p = state.particles[i];
        p.life -= dt;
        if(p.life<=0){ state.particles.splice(i,1); continue; }
        p.x += p.vx*dt; p.y += p.vy*dt;
        p.vx *= Math.exp(-2.5*dt);
        p.vy *= Math.exp(-2.5*dt);
      }
    }

    function updateFloatTexts(dt){
      for(let i=state.floatTexts.length-1;i>=0;i--){
        const t = state.floatTexts[i];
        t.life -= dt;
        if(t.life<=0){ state.floatTexts.splice(i,1); continue; }
        t.y -= 28*dt;
      }
    }

    function scoreUpdate(dt){
      state.time += dt;
      state.score += dt;
      state.gridOffset = (state.gridOffset + 34*dt) % 28;
      state.pulseCooldown = Math.max(0, state.pulseCooldown - dt);
      state.difficultyTier = clamp(1 + Math.floor(state.time/14), 1, TIER_NAMES.length);
    }

    function updateGame(dt){
      updatePlayers(dt);
      spawnHazards(dt);
      updateHazards(dt);
      checkCollisions();
      if(state.screen !== "playing") return;
      scoreUpdate(dt);
      updateParticles(dt);
      updateFloatTexts(dt);
      updatePulseButton();
    }

    function drawBackground(){
      ctx.clearRect(0,0,WORLD_W,WORLD_H);
      const bg = ctx.createLinearGradient(0,0,0,WORLD_H);
      bg.addColorStop(0,"#0b1030");
      bg.addColorStop(1,"#04040f");
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,WORLD_W,WORLD_H);

      for(let arena=0; arena<2; arena++){
        const ox = arena*ARENA_W;
        const tone = arena===0 ? "rgba(45,244,255,.04)" : "rgba(255,95,230,.04)";
        ctx.fillStyle = tone;
        ctx.fillRect(ox,PLAY_TOP,ARENA_W,PLAY_BOTTOM-PLAY_TOP);

        ctx.strokeStyle = arena===0 ? "rgba(45,244,255,.12)" : "rgba(255,95,230,.12)";
        ctx.lineWidth = 1;

        for(let x=0; x<=ARENA_W; x+=30){
          const gx = ox + x + (state.gridOffset*(arena===0?1:-1));
          ctx.beginPath(); ctx.moveTo(gx,PLAY_TOP); ctx.lineTo(gx,PLAY_BOTTOM); ctx.stroke();
        }
        for(let y=PLAY_TOP; y<=PLAY_BOTTOM; y+=28){
          const gy = y + state.gridOffset;
          ctx.beginPath(); ctx.moveTo(ox,gy); ctx.lineTo(ox+ARENA_W,gy); ctx.stroke();
        }
      }

      ctx.strokeStyle="rgba(186,153,255,.45)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(ARENA_W,PLAY_TOP); ctx.lineTo(ARENA_W,PLAY_BOTTOM); ctx.stroke();
    }

    function drawHud(){
      ctx.fillStyle="rgba(7,11,27,.9)";
      ctx.fillRect(0,0,WORLD_W,HUD_H);

      ctx.strokeStyle="rgba(100,162,255,.35)";
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(0,HUD_H); ctx.lineTo(WORLD_W,HUD_H); ctx.stroke();

      const scoreValue = Math.floor(state.score);
      const tierName = TIER_NAMES[state.difficultyTier-1] || TIER_NAMES[TIER_NAMES.length-1];

      ctx.font="bold 16px Courier New, monospace";
      ctx.fillStyle="#b4f6ff";
      ctx.textAlign="left";
      ctx.fillText(`Score ${scoreValue}`,16,22);
      ctx.fillStyle="#f6b3ff";
      ctx.fillText(`Best ${Math.floor(state.best)}`,16,42);

      ctx.textAlign="center";
      ctx.fillStyle="#d6deff";
      ctx.fillText(`Time ${state.time.toFixed(1)}s`,WORLD_W*.5,22);
      ctx.fillStyle="#ffd67e";
      ctx.fillText(`Tier ${state.difficultyTier}: ${tierName}`,WORLD_W*.5,42);

      ctx.textAlign="right";
      if(state.pulseCooldown<=0){
        ctx.fillStyle="#86ffd6";
        ctx.fillText("Pulse READY",WORLD_W-16,22);
      }else{
        ctx.fillStyle="#e0a6ff";
        ctx.fillText(`Pulse ${state.pulseCooldown.toFixed(1)}s`,WORLD_W-16,22);
      }
      ctx.fillStyle="#9fc6ff";
      ctx.fillText("WASD | ARROWS | SPACE",WORLD_W-16,42);
    }

    function drawHazards(timeSec){
      for(const h of state.hazards){
        const ox = h.arena*ARENA_W;

        if(h.type==="dart"){
          if(h.phase==="telegraph"){
            const blink = .45 + .3*Math.sin(timeSec*14 + h.id);
            const dashLen = 880;
            ctx.save();
            ctx.strokeStyle = `rgba(255,168,94,${blink.toFixed(3)})`;
            ctx.lineWidth=2;
            ctx.setLineDash([7,6]);
            ctx.beginPath();
            ctx.moveTo(ox+h.x,h.y);
            ctx.lineTo(ox+h.x+h.dirX*dashLen, h.y+h.dirY*dashLen);
            ctx.stroke();
            ctx.restore();

            ctx.fillStyle="rgba(255,190,120,.75)";
            ctx.beginPath(); ctx.arc(ox+h.x,h.y,4.5,0,Math.PI*2); ctx.fill();
          }else if(h.phase==="active"){
            const wx=ox+h.x, wy=h.y;
            ctx.strokeStyle="rgba(255,180,110,.55)";
            ctx.lineWidth=2;
            ctx.beginPath();
            ctx.moveTo(wx-h.dirX*20, wy-h.dirY*20);
            ctx.lineTo(wx+h.dirX*8, wy+h.dirY*8);
            ctx.stroke();

            ctx.fillStyle="#ffb676";
            ctx.shadowColor="#ff9b4b";
            ctx.shadowBlur=14;
            ctx.beginPath(); ctx.arc(wx,wy,h.radius,0,Math.PI*2); ctx.fill();
            ctx.shadowBlur=0;
          }
        }else{
          const alphaPulse = .35 + .32*Math.sin(timeSec*16 + h.id);
          const beamColor = h.arena===0 ? "45, 244, 255" : "255, 95, 230";

          if(h.phase==="telegraph"){
            ctx.save();
            ctx.strokeStyle = `rgba(${beamColor}, ${Math.max(.12, alphaPulse).toFixed(3)})`;
            ctx.lineWidth=h.thickness;
            ctx.setLineDash([10,8]);
            ctx.beginPath();
            if(h.vertical){
              ctx.moveTo(ox+h.pos, PLAY_TOP);
              ctx.lineTo(ox+h.pos, PLAY_BOTTOM);
            }else{
              ctx.moveTo(ox+8, h.pos);
              ctx.lineTo(ox+ARENA_W-8, h.pos);
            }
            ctx.stroke();
            ctx.restore();
          }else if(h.phase==="active"){
            ctx.strokeStyle = `rgba(${beamColor}, .95)`;
            ctx.lineWidth=h.thickness;
            ctx.shadowColor = `rgba(${beamColor}, .75)`;
            ctx.shadowBlur=20;
            ctx.beginPath();
            if(h.vertical){
              ctx.moveTo(ox+h.pos, PLAY_TOP);
              ctx.lineTo(ox+h.pos, PLAY_BOTTOM);
            }else{
              ctx.moveTo(ox+8, h.pos);
              ctx.lineTo(ox+ARENA_W-8, h.pos);
            }
            ctx.stroke();
            ctx.shadowBlur=0;
          }else if(h.phase==="cooldown"){
            const fade = clamp(h.timer/.2,0,1);
            ctx.strokeStyle = `rgba(${beamColor}, ${.4*fade})`;
            ctx.lineWidth=h.thickness;
            ctx.beginPath();
            if(h.vertical){
              ctx.moveTo(ox+h.pos, PLAY_TOP);
              ctx.lineTo(ox+h.pos, PLAY_BOTTOM);
            }else{
              ctx.moveTo(ox+8, h.pos);
              ctx.lineTo(ox+ARENA_W-8, h.pos);
            }
            ctx.stroke();
          }
        }
      }
    }

    function drawPlayers(){
      for(const p of players){
        const wx = worldX(p.arena, p.x);
        const wy = p.y;
        const glow = p.arena===0 ? "45, 244, 255" : "255, 95, 230";

        ctx.fillStyle = `rgba(${glow}, .95)`;
        ctx.shadowColor = `rgba(${glow}, .9)`;
        ctx.shadowBlur=18;
        ctx.beginPath(); ctx.arc(wx,wy,p.radius,0,Math.PI*2); ctx.fill();
        ctx.shadowBlur=0;

        ctx.strokeStyle="rgba(255,255,255,.75)";
        ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.arc(wx,wy,p.radius+2.8,0,Math.PI*2); ctx.stroke();

        if(p.hitFlash>0){
          ctx.fillStyle = `rgba(255,255,255,${clamp(p.hitFlash*2.2,0,1)})`;
          ctx.beginPath(); ctx.arc(wx,wy,p.radius+8,0,Math.PI*2); ctx.fill();
        }
      }
    }

    function colorWithAlpha(color, a){
      if(!color) return `rgba(255,255,255,${a})`;
      if(color.startsWith("rgba(")) return color.replace(/rgba\(([^)]+),\s*[\d.]+\)/, `rgba($1, ${a})`);
      if(color.startsWith("rgb(")) return color.replace("rgb(", "rgba(").replace(")", `, ${a})`);
      if(color[0]==="#"){
        let hex = color.slice(1);
        if(hex.length===3) hex = hex.split("").map(c=>c+c).join("");
        if(hex.length===6){
          const int = parseInt(hex,16);
          const r=(int>>16)&255, g=(int>>8)&255, b=int&255;
          return `rgba(${r},${g},${b},${a})`;
        }
      }
      return `rgba(255,255,255,${a})`;
    }

    function drawParticles(){
      for(const p of state.particles){
        const a = clamp(p.life/p.maxLife,0,1);
        ctx.fillStyle = colorWithAlpha(p.color, a.toFixed(3));
        ctx.beginPath(); ctx.arc(p.x,p.y,1.9,0,Math.PI*2); ctx.fill();
      }
    }

    function drawFloatTexts(){
      ctx.textAlign="left";
      ctx.font="bold 15px Courier New, monospace";
      for(const t of state.floatTexts){
        ctx.fillStyle=t.color;
        ctx.globalAlpha=clamp(t.life/.9,0,1);
        ctx.fillText(t.text, t.x, t.y);
      }
      ctx.globalAlpha=1;
    }

    function drawJoystickHints(){
      if(!isTouchDevice || state.screen!=="playing") return;

      for(let side=0; side<2; side++){
        const j = joysticks[side];
        if(!j.active){
          const cx = side===0 ? ARENA_W*.25 : ARENA_W*1.75;
          const cy = WORLD_H-78;
          ctx.strokeStyle="rgba(180,210,255,.25)";
          ctx.lineWidth=2;
          ctx.beginPath(); ctx.arc(cx,cy,30,0,Math.PI*2); ctx.stroke();
          continue;
        }
        ctx.strokeStyle="rgba(182,216,255,.45)";
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(j.centerX,j.centerY,38,0,Math.PI*2); ctx.stroke();

        ctx.fillStyle="rgba(206,230,255,.45)";
        ctx.beginPath(); ctx.arc(j.knobX,j.knobY,15,0,Math.PI*2); ctx.fill();
      }
    }

    function draw(timeSec){
      drawBackground();
      drawHazards(timeSec);
      drawPlayers();
      drawParticles();
      drawFloatTexts();
      drawJoystickHints();
      drawHud();
    }

    function loop(now){
      const dt = Math.min(.033, (now-lastFrame)/1000);
      lastFrame = now;

      if(state.screen==="playing") updateGame(dt);
      else { updateParticles(dt); updateFloatTexts(dt); }

      draw(now*.001);
      requestAnimationFrame(loop);
    }

    function clientToWorld(cx,cy){
      const rect = canvas.getBoundingClientRect();
      return {
        x: ((cx-rect.left)/rect.width)*WORLD_W,
        y: ((cy-rect.top)/rect.height)*WORLD_H
      };
    }

    function updateJoystickFromPoint(side, wx, wy){
      const j = joysticks[side];
      const maxR = 44;
      const dx = wx - j.centerX;
      const dy = wy - j.centerY;
      const dist = Math.hypot(dx,dy);
      let kx=dx, ky=dy;
      if(dist>maxR && dist>0){
        const r = maxR/dist;
        kx*=r; ky*=r;
      }
      j.knobX = j.centerX + kx;
      j.knobY = j.centerY + ky;
      j.vecX = kx/maxR;
      j.vecY = ky/maxR;
    }

    function handlePointerDown(e){
      if(state.screen!=="playing") return;
      if(e.target===pulseBtn) return;

      const pt = clientToWorld(e.clientX, e.clientY);
      const side = pt.x < ARENA_W ? 0 : 1;
      const j = joysticks[side];
      const now = performance.now();

      if(now - j.lastTapAt < 280) triggerDash(side);
      j.lastTapAt = now;

      if(!j.active){
        j.active=true;
        j.pointerId=e.pointerId;
        j.centerX=pt.x; j.centerY=pt.y;
        j.knobX=pt.x; j.knobY=pt.y;
        j.vecX=0; j.vecY=0;
      }

      pointerToSide.set(e.pointerId, side);
      try{ canvas.setPointerCapture(e.pointerId); }catch{}
      if(j.pointerId===e.pointerId) updateJoystickFromPoint(side, pt.x, pt.y);
    }

    function handlePointerMove(e){
      if(state.screen!=="playing") return;
      const side = pointerToSide.get(e.pointerId);
      if(side==null) return;
      const j = joysticks[side];
      if(!j.active || j.pointerId!==e.pointerId) return;
      const pt = clientToWorld(e.clientX, e.clientY);
      updateJoystickFromPoint(side, pt.x, pt.y);
    }

    function releasePointer(pid){
      const side = pointerToSide.get(pid);
      if(side==null) return;
      pointerToSide.delete(pid);

      const j = joysticks[side];
      if(j.pointerId===pid){
        j.active=false;
        j.pointerId=null;
        j.vecX=0;j.vecY=0;
        j.knobX=j.centerX;
        j.knobY=j.centerY;
      }
    }

    // canvas (only active while playing)
    canvas.addEventListener("pointerdown", (e)=>{ ensureAudio(); handlePointerDown(e); });
    canvas.addEventListener("pointermove", handlePointerMove);
    canvas.addEventListener("pointerup", (e)=>releasePointer(e.pointerId));
    canvas.addEventListener("pointercancel", (e)=>releasePointer(e.pointerId));
    canvas.addEventListener("lostpointercapture", (e)=>releasePointer(e.pointerId));

    window.addEventListener("keydown", (e)=>{
      if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
      keyState[e.code]=true;

      if(e.code==="Space" && !e.repeat) tryRiftPulse();
      else if(e.code==="Enter" && !e.repeat){
        if(state.screen!=="playing") startRun();
      }
    });
    window.addEventListener("keyup", (e)=>{ keyState[e.code]=false; });

    window.addEventListener("resize", resizeCanvas);

    // ✅ ULTRA SAFE: click + pointerdown
    startBtn.addEventListener("click", ()=>{ ensureAudio(); startRun(); });
    startBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); ensureAudio(); startRun(); });

    restartBtn.addEventListener("click", ()=>{ ensureAudio(); startRun(); });
    restartBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); ensureAudio(); startRun(); });

    soundBtn.addEventListener("click", ()=>{ ensureAudio(); toggleSound(); });
    soundBtnGameOver.addEventListener("click", ()=>{ ensureAudio(); toggleSound(); });

    pulseBtn.addEventListener("click", ()=>{ ensureAudio(); tryRiftPulse(); });
    pulseBtn.addEventListener("pointerdown", (e)=>{ e.stopPropagation(); });

    updateSoundLabels();
    updateStartBestLine();

    // start/gameover: canvas must NOT steal taps
    setCanvasInteractive(false);

    resizeCanvas();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
