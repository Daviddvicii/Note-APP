<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#060913" />
    <title>Neon Rift Split</title>
    <style>
      :root {
        --bg: #060913;
        --panel: rgba(8, 14, 28, 0.86);
        --line: rgba(110, 198, 255, 0.32);
        --cyan: #42e8ff;
        --pink: #ff4de3;
        --lime: #b5ff58;
        --text: #d8f7ff;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: var(--bg);
        color: var(--text);
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        touch-action: none;
      }

      #app {
        position: fixed;
        inset: 0;
        overflow: hidden;
      }

      #game {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      .scanlines,
      .vignette {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .scanlines {
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.16));
        background-size: 100% 4px;
        mix-blend-mode: overlay;
        opacity: 0.5;
        z-index: 8;
      }

      .vignette {
        background:
          radial-gradient(circle at 50% 40%, rgba(82, 204, 255, 0.08), rgba(6, 9, 19, 0.75) 58%, rgba(4, 6, 14, 0.95) 100%),
          radial-gradient(circle at 50% 65%, rgba(255, 77, 227, 0.08), transparent 45%);
        animation: crt-flicker 5.8s infinite;
        z-index: 9;
      }

      @keyframes crt-flicker {
        0%,
        100% {
          opacity: 0.9;
        }
        10% {
          opacity: 0.83;
        }
        11% {
          opacity: 0.92;
        }
        54% {
          opacity: 0.86;
        }
        55% {
          opacity: 0.93;
        }
      }

      .floating-controls {
        position: absolute;
        top: 12px;
        right: 12px;
        display: flex;
        gap: 8px;
        z-index: 20;
      }

      .ui-btn {
        appearance: none;
        border: 1px solid var(--line);
        background: var(--panel);
        color: var(--text);
        border-radius: 999px;
        padding: 8px 12px;
        font: inherit;
        font-size: 12px;
        cursor: pointer;
        box-shadow: 0 0 10px rgba(66, 232, 255, 0.2);
        transition: 0.14s ease;
      }

      .ui-btn:hover {
        border-color: rgba(66, 232, 255, 0.7);
        color: #ecfdff;
        box-shadow: 0 0 16px rgba(66, 232, 255, 0.45);
      }

      .ui-btn:disabled {
        opacity: 0.55;
        cursor: default;
      }

      #riftBtn {
        position: absolute;
        left: 50%;
        bottom: 12px;
        transform: translateX(-50%);
        z-index: 20;
        min-width: 140px;
      }

      .overlay {
        position: absolute;
        inset: 0;
        z-index: 30;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
        background: rgba(4, 8, 16, 0.82);
        backdrop-filter: blur(2px);
      }

      .panel {
        width: min(720px, 96vw);
        border: 1px solid var(--line);
        border-radius: 16px;
        padding: 22px 18px;
        background: linear-gradient(180deg, rgba(9, 14, 30, 0.88), rgba(5, 10, 22, 0.9));
        box-shadow: 0 0 28px rgba(66, 232, 255, 0.2), inset 0 0 24px rgba(255, 77, 227, 0.06);
        text-align: center;
      }

      h1 {
        margin: 0 0 10px;
        font-size: clamp(28px, 5.2vw, 46px);
        letter-spacing: 0.07em;
        text-transform: uppercase;
        color: #f4feff;
        text-shadow: 0 0 18px rgba(66, 232, 255, 0.5);
      }

      .tagline {
        margin: 0 0 12px;
        color: #8ddcff;
        font-size: clamp(13px, 2.6vw, 18px);
      }

      .rule {
        margin: 6px 0;
        color: #ddf8ff;
        opacity: 0.9;
        font-size: clamp(12px, 2.3vw, 16px);
      }

      .danger {
        color: #ff9cf0;
      }

      .stats {
        margin-top: 14px;
        font-size: clamp(12px, 2.2vw, 15px);
        color: #c9ebff;
      }

      .actions {
        margin-top: 18px;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 10px;
      }

      .primary {
        appearance: none;
        border: 1px solid rgba(66, 232, 255, 0.72);
        border-radius: 12px;
        background: rgba(14, 26, 52, 0.9);
        color: #ecfdff;
        font: inherit;
        font-size: 16px;
        padding: 11px 18px;
        cursor: pointer;
        box-shadow: 0 0 18px rgba(66, 232, 255, 0.35);
      }

      .primary:hover {
        box-shadow: 0 0 24px rgba(66, 232, 255, 0.5);
      }

      .secondary {
        appearance: none;
        border: 1px solid rgba(255, 77, 227, 0.55);
        border-radius: 12px;
        background: rgba(35, 14, 44, 0.72);
        color: #ffd8f9;
        font: inherit;
        font-size: 15px;
        padding: 10px 16px;
        cursor: pointer;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas id="game"></canvas>
      <div class="scanlines"></div>
      <div class="vignette"></div>

      <div class="floating-controls">
        <button id="soundBtn" class="ui-btn" type="button">Sound: ON</button>
      </div>
      <button id="riftBtn" class="ui-btn hidden" type="button">RIFT</button>

      <div id="startScreen" class="overlay">
        <div class="panel">
          <h1>Neon Rift Split</h1>
          <p class="tagline">Fight your own attention budget.</p>
          <p class="rule">Desktop: Left = WASD, Right = Arrow Keys, Space = Rift Pulse.</p>
          <p class="rule">Mobile: Two virtual joysticks. Double-tap each side to dash.</p>
          <p class="rule danger">Either avatar dies and the run is over.</p>
          <p class="stats">
            Best Score: <b id="startBest">0</b>
            &nbsp;|&nbsp;
            Best Time: <b id="startBestTime">0.0s</b>
          </p>
          <div class="actions">
            <button id="startBtn" class="primary" type="button">Start Run</button>
            <button id="startSoundBtn" class="secondary" type="button">Sound: ON</button>
          </div>
        </div>
      </div>

      <div id="gameOverScreen" class="overlay hidden">
        <div class="panel">
          <h1>Game Over</h1>
          <p class="tagline" id="deathReason">One side got clipped.</p>
          <p class="rule">Time Survived: <b id="finalTime">0.0s</b></p>
          <p class="rule">Score: <b id="finalScore">0</b></p>
          <p class="rule">Best: <b id="finalBest">0</b></p>
          <div class="actions">
            <button id="restartBtn" class="primary" type="button">Restart</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        // ===== Constants =====
        const WORLD_W = 900;
        const WORLD_H = 600;
        const ARENA_W = WORLD_W * 0.5;
        const HUD_H = 74;
        const PLAY_TOP = HUD_H + 4;
        const PLAY_BOTTOM = WORLD_H - 10;
        const PLAY_H = PLAY_BOTTOM - PLAY_TOP;

        const PLAYER_ACCEL = 1700;
        const PLAYER_FRICTION = 7.2;
        const PLAYER_MAX_SPEED = 290;
        const DASH_BOOST = 520;
        const DASH_CD = 0.9;
        const RIFT_COOLDOWN = 6;
        const MAX_HAZARDS = 96;
        const MAX_PARTICLES = 320;
        const JOYSTICK_R = 58;

        const BEST_KEY = "neon-rift-best";
        const SOUND_KEY = "neon-rift-sound";
        const TOTAL_RUNS_KEY = "neon-rift-total-runs";
        const BEST_TIME_KEY = "neon-rift-best-time";

        // ===== DOM =====
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        const soundBtn = document.getElementById("soundBtn");
        const startSoundBtn = document.getElementById("startSoundBtn");
        const riftBtn = document.getElementById("riftBtn");

        const startScreen = document.getElementById("startScreen");
        const gameOverScreen = document.getElementById("gameOverScreen");
        const startBtn = document.getElementById("startBtn");
        const restartBtn = document.getElementById("restartBtn");

        const startBestEl = document.getElementById("startBest");
        const startBestTimeEl = document.getElementById("startBestTime");
        const deathReasonEl = document.getElementById("deathReason");
        const finalTimeEl = document.getElementById("finalTime");
        const finalScoreEl = document.getElementById("finalScore");
        const finalBestEl = document.getElementById("finalBest");

        // ===== Math helpers =====
        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const randRange = (a, b) => a + Math.random() * (b - a);
        const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);
        function norm(x, y) {
          const m = Math.hypot(x, y) || 1;
          return { x: x / m, y: y / m };
        }

        function lsGetNumber(key, fallback) {
          try {
            const raw = localStorage.getItem(key);
            if (raw == null) return fallback;
            const n = Number(raw);
            return Number.isFinite(n) ? n : fallback;
          } catch (_) {
            return fallback;
          }
        }

        function lsSet(key, value) {
          try {
            localStorage.setItem(key, String(value));
          } catch (_) {}
        }

        // ===== Audio (optional) =====
        let audioCtx = null;
        let soundOn = lsGetNumber(SOUND_KEY, 1) !== 0;

        function ensureAudio() {
          if (audioCtx) return;
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) return;
          audioCtx = new AC();
        }

        function blip(freq = 440, dur = 0.08, type = "square", gain = 0.05, slideTo = 0) {
          if (!soundOn) return;
          ensureAudio();
          if (!audioCtx) return;
          if (audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
          const t = audioCtx.currentTime;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type;
          o.frequency.setValueAtTime(Math.max(1, freq), t);
          if (slideTo > 0) o.frequency.exponentialRampToValueAtTime(Math.max(1, slideTo), t + dur);
          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
          o.connect(g);
          g.connect(audioCtx.destination);
          o.start(t);
          o.stop(t + dur + 0.02);
        }

        function syncSoundLabels() {
          const text = soundOn ? "Sound: ON" : "Sound: OFF";
          soundBtn.textContent = text;
          startSoundBtn.textContent = text;
        }

        function toggleSound() {
          soundOn = !soundOn;
          lsSet(SOUND_KEY, soundOn ? 1 : 0);
          syncSoundLabels();
          blip(soundOn ? 900 : 240, 0.06, "square", 0.05);
        }

        // ===== Responsive canvas transform =====
        let dpr = 1;
        let viewW = 1;
        let viewH = 1;
        let scale = 1;
        let offX = 0;
        let offY = 0;

        function resize() {
          viewW = Math.max(1, window.innerWidth);
          viewH = Math.max(1, window.innerHeight);
          dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
          canvas.width = Math.round(viewW * dpr);
          canvas.height = Math.round(viewH * dpr);
          canvas.style.width = `${viewW}px`;
          canvas.style.height = `${viewH}px`;
          scale = Math.min(viewW / WORLD_W, viewH / WORLD_H);
          offX = (viewW - WORLD_W * scale) * 0.5;
          offY = (viewH - WORLD_H * scale) * 0.5;
        }

        function pointerToWorld(clientX, clientY) {
          const x = (clientX - offX) / scale;
          const y = (clientY - offY) / scale;
          const inside = x >= 0 && x <= WORLD_W && y >= 0 && y <= WORLD_H;
          return { x, y, inside };
        }

        // ===== Game state =====
        const state = {
          mode: "start", // start | running | gameover
          time: 0,
          timeSurvived: 0,
          score: 0,
          best: Math.floor(lsGetNumber(BEST_KEY, 0)),
          bestTime: lsGetNumber(BEST_TIME_KEY, 0),
          totalRuns: Math.floor(lsGetNumber(TOTAL_RUNS_KEY, 0)),
          difficultyTier: 1,
          riftCooldown: 0,
          pulseFlash: 0,
          spawnTimers: [0, 0],
          nextSpawn: [1, 1.2],
        };

        function makePlayer(side, color) {
          return {
            side,
            color,
            x: ARENA_W * 0.5,
            y: PLAY_H * 0.7,
            vx: 0,
            vy: 0,
            r: 12,
            dashCd: 0,
            dashFx: 0,
            lastInputX: 0,
            lastInputY: -1,
          };
        }

        let players = [makePlayer(0, "#46eaff"), makePlayer(1, "#ff58e4")];
        const hazards = [];
        const particles = [];
        const floatTexts = [];
        const keys = new Set();

        const joysticks = [
          {
            side: 0,
            active: false,
            id: null,
            baseX: 112,
            baseY: WORLD_H - 100,
            x: 112,
            y: WORLD_H - 100,
            dx: 0,
            dy: 0,
            lastTap: 0,
          },
          {
            side: 1,
            active: false,
            id: null,
            baseX: WORLD_W - 112,
            baseY: WORLD_H - 100,
            x: WORLD_W - 112,
            y: WORLD_H - 100,
            dx: 0,
            dy: 0,
            lastTap: 0,
          },
        ];

        let touchUi = navigator.maxTouchPoints > 0;
        let hazardIdSeq = 1;

        function resetJoystick(side) {
          const j = joysticks[side];
          j.active = false;
          j.id = null;
          j.dx = 0;
          j.dy = 0;
          j.baseX = side === 0 ? 112 : WORLD_W - 112;
          j.baseY = WORLD_H - 100;
          j.x = j.baseX;
          j.y = j.baseY;
        }

        function resetRunEntities() {
          players = [makePlayer(0, "#46eaff"), makePlayer(1, "#ff58e4")];
          hazards.length = 0;
          particles.length = 0;
          floatTexts.length = 0;
          resetJoystick(0);
          resetJoystick(1);
        }

        function refreshStartStats() {
          startBestEl.textContent = String(state.best | 0);
          startBestTimeEl.textContent = `${state.bestTime.toFixed(1)}s`;
        }

        function updateRiftButton() {
          if (state.mode !== "running") {
            riftBtn.classList.add("hidden");
            riftBtn.disabled = true;
            return;
          }
          riftBtn.classList.remove("hidden");
          const ready = state.riftCooldown <= 0;
          riftBtn.disabled = !ready;
          riftBtn.textContent = ready ? "RIFT READY" : `RIFT ${state.riftCooldown.toFixed(1)}s`;
        }

        function startRun() {
          ensureAudio();
          state.mode = "running";
          state.timeSurvived = 0;
          state.score = 0;
          state.difficultyTier = 1;
          state.riftCooldown = 0;
          state.pulseFlash = 0;
          state.spawnTimers[0] = 0;
          state.spawnTimers[1] = 0;
          state.nextSpawn[0] = 0.85;
          state.nextSpawn[1] = 1.1;
          state.totalRuns += 1;
          lsSet(TOTAL_RUNS_KEY, state.totalRuns);
          resetRunEntities();
          startScreen.classList.add("hidden");
          gameOverScreen.classList.add("hidden");
          updateRiftButton();
          blip(640, 0.08, "triangle", 0.05, 920);
        }

        function endRun(deadSide, reason) {
          if (state.mode !== "running") return;
          state.mode = "gameover";
          const scoreInt = Math.floor(state.score);
          if (scoreInt > state.best) {
            state.best = scoreInt;
            lsSet(BEST_KEY, state.best);
          }
          if (state.timeSurvived > state.bestTime) {
            state.bestTime = state.timeSurvived;
            lsSet(BEST_TIME_KEY, state.bestTime.toFixed(2));
          }
          finalScoreEl.textContent = String(scoreInt);
          finalTimeEl.textContent = `${state.timeSurvived.toFixed(1)}s`;
          finalBestEl.textContent = String(state.best | 0);
          deathReasonEl.textContent = `${deadSide === 0 ? "Left" : "Right"} side got hit by ${reason}.`;
          gameOverScreen.classList.remove("hidden");
          updateRiftButton();
          refreshStartStats();
          blip(120, 0.24, "sawtooth", 0.08, 42);
        }

        function currentTuning() {
          const t = state.timeSurvived;
          const tier = 1 + Math.floor(t / 18);
          state.difficultyTier = tier;
          return {
            tier,
            spawnInterval: Math.max(0.48, 1.55 - t * 0.01),
            dartTele: Math.max(0.28, 0.6 - t * 0.0035),
            laserTele: Math.max(0.5, 0.9 - t * 0.004),
            dartSpeed: 290 + tier * 38,
            laserSpeed: 340 + tier * 34,
          };
        }

        function getKeyboardInput(side) {
          let x = 0;
          let y = 0;
          if (side === 0) {
            if (keys.has("KeyW")) y -= 1;
            if (keys.has("KeyS")) y += 1;
            if (keys.has("KeyA")) x -= 1;
            if (keys.has("KeyD")) x += 1;
          } else {
            if (keys.has("ArrowUp")) y -= 1;
            if (keys.has("ArrowDown")) y += 1;
            if (keys.has("ArrowLeft")) x -= 1;
            if (keys.has("ArrowRight")) x += 1;
          }
          const m = Math.hypot(x, y);
          if (m > 1) {
            x /= m;
            y /= m;
          }
          return { x, y };
        }

        function triggerDash(side) {
          if (state.mode !== "running") return false;
          const p = players[side];
          if (!p || p.dashCd > 0) return false;
          const keyIn = getKeyboardInput(side);
          const joy = joysticks[side];
          let dx = keyIn.x + (joy.active ? joy.dx : 0);
          let dy = keyIn.y + (joy.active ? joy.dy : 0);
          if (Math.hypot(dx, dy) < 0.12) {
            dx = p.lastInputX;
            dy = p.lastInputY;
          }
          const d = norm(dx, dy);
          p.vx += d.x * DASH_BOOST;
          p.vy += d.y * DASH_BOOST;
          p.dashCd = DASH_CD;
          p.dashFx = 0.16;
          burst(side, p.x, p.y, p.color, 10, 220);
          blip(560, 0.07, "square", 0.05, 1020);
          return true;
        }

        function triggerRiftPulse() {
          if (state.mode !== "running") return false;
          if (state.riftCooldown > 0) return false;
          const a = players[0];
          const b = players[1];
          const tx = a.x;
          const ty = a.y;
          const tvx = a.vx;
          const tvy = a.vy;
          a.x = b.x;
          a.y = b.y;
          a.vx = b.vx;
          a.vy = b.vy;
          b.x = tx;
          b.y = ty;
          b.vx = tvx;
          b.vy = tvy;
          state.riftCooldown = RIFT_COOLDOWN;
          state.pulseFlash = 0.25;
          burst(0, a.x, a.y, "#a68dff", 18, 260);
          burst(1, b.x, b.y, "#a68dff", 18, 260);
          blip(240, 0.1, "triangle", 0.07, 860);
          return true;
        }

        function randomEdgePoint() {
          const edge = (Math.random() * 4) | 0;
          if (edge === 0) return { x: randRange(0, ARENA_W), y: -20 };
          if (edge === 1) return { x: ARENA_W + 20, y: randRange(0, PLAY_H) };
          if (edge === 2) return { x: randRange(0, ARENA_W), y: PLAY_H + 20 };
          return { x: -20, y: randRange(0, PLAY_H) };
        }

        function makeDart(side, tuning) {
          const spawn = randomEdgePoint();
          const p = players[side];
          const tx = clamp(p.x + randRange(-26, 26), 0, ARENA_W);
          const ty = clamp(p.y + randRange(-26, 26), 0, PLAY_H);
          const d = norm(tx - spawn.x, ty - spawn.y);
          const tele = tuning.dartTele;
          return {
            id: hazardIdSeq++,
            side,
            kind: "dart",
            phase: "telegraph",
            timer: tele,
            telegraph: tele,
            active: 2.3,
            cooldown: 0.2,
            x: spawn.x,
            y: spawn.y,
            startX: spawn.x,
            startY: spawn.y,
            dirX: d.x,
            dirY: d.y,
            speed: tuning.dartSpeed,
            r: 8.5,
            nearAwarded: false,
          };
        }

        function makeLaser(side, tuning) {
          const vertical = Math.random() < 0.5;
          const dir = Math.random() < 0.5 ? 1 : -1;
          const tele = tuning.laserTele;
          return {
            id: hazardIdSeq++,
            side,
            kind: "laser",
            phase: "telegraph",
            timer: tele,
            telegraph: tele,
            active: 0.3,
            cooldown: 0.2,
            vertical,
            pos: dir > 0 ? -42 : (vertical ? ARENA_W + 42 : PLAY_H + 42),
            vel: dir * tuning.laserSpeed,
            width: 24,
            nearAwarded: false,
          };
        }

        function hazardsInSide(side) {
          let c = 0;
          for (let i = 0; i < hazards.length; i++) if (hazards[i].side === side) c++;
          return c;
        }

        function spawnHazard(side, tuning) {
          if (hazards.length >= MAX_HAZARDS) return;
          if (hazardsInSide(side) >= 44) return;
          const h = Math.random() < 0.62 ? makeDart(side, tuning) : makeLaser(side, tuning);
          hazards.push(h);
        }

        function updatePlayers(dt) {
          for (let side = 0; side < 2; side++) {
            const p = players[side];
            const keyIn = getKeyboardInput(side);
            const j = joysticks[side];
            let ix = keyIn.x + (j.active ? j.dx : 0);
            let iy = keyIn.y + (j.active ? j.dy : 0);
            const m = Math.hypot(ix, iy);
            if (m > 1) {
              ix /= m;
              iy /= m;
            }
            if (m > 0.08) {
              p.lastInputX = ix;
              p.lastInputY = iy;
            }
            p.vx += ix * PLAYER_ACCEL * dt;
            p.vy += iy * PLAYER_ACCEL * dt;

            const damping = Math.exp(-PLAYER_FRICTION * dt);
            p.vx *= damping;
            p.vy *= damping;

            const sp = Math.hypot(p.vx, p.vy);
            const top = PLAYER_MAX_SPEED + (p.dashFx > 0 ? 140 : 0);
            if (sp > top) {
              p.vx = (p.vx / sp) * top;
              p.vy = (p.vy / sp) * top;
            }

            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.x = clamp(p.x, p.r + 2, ARENA_W - p.r - 2);
            p.y = clamp(p.y, p.r + 2, PLAY_H - p.r - 2);
            p.dashCd = Math.max(0, p.dashCd - dt);
            p.dashFx = Math.max(0, p.dashFx - dt);
          }
        }

        function spawnHazards(dt, tuning) {
          for (let side = 0; side < 2; side++) {
            state.spawnTimers[side] += dt;
            if (state.spawnTimers[side] >= state.nextSpawn[side]) {
              state.spawnTimers[side] = 0;
              state.nextSpawn[side] = tuning.spawnInterval * randRange(0.8, 1.28);
              spawnHazard(side, tuning);
              if (tuning.tier >= 6 && Math.random() < 0.17) spawnHazard(side, tuning);
            }
          }
        }

        function updateHazards(dt) {
          for (let i = hazards.length - 1; i >= 0; i--) {
            const h = hazards[i];
            if (h.phase === "telegraph") {
              h.timer -= dt;
              if (h.kind === "laser") {
                h.pos += h.vel * dt * 0.35;
              }
              if (h.timer <= 0) {
                h.phase = "active";
                h.timer = h.active;
              }
            } else if (h.phase === "active") {
              h.timer -= dt;
              if (h.kind === "dart") {
                h.x += h.dirX * h.speed * dt;
                h.y += h.dirY * h.speed * dt;
              } else {
                h.pos += h.vel * dt;
              }
              if (h.timer <= 0) {
                h.phase = "cooldown";
                h.timer = h.cooldown;
              }
            } else {
              h.timer -= dt;
              if (h.kind === "dart") {
                h.x += h.dirX * h.speed * dt * 0.45;
                h.y += h.dirY * h.speed * dt * 0.45;
              } else {
                h.pos += h.vel * dt * 0.35;
              }
              if (h.timer <= 0) {
                hazards.splice(i, 1);
                continue;
              }
            }

            if (
              h.kind === "dart" &&
              (h.x < -70 || h.x > ARENA_W + 70 || h.y < -70 || h.y > PLAY_H + 70) &&
              h.phase !== "telegraph"
            ) {
              hazards.splice(i, 1);
              continue;
            }
          }
        }

        function addFloat(side, x, y, text, color) {
          floatTexts.push({
            side,
            x,
            y,
            text,
            color,
            life: 0.85,
            vy: randRange(-24, -14),
          });
          if (floatTexts.length > 36) floatTexts.shift();
        }

        function awardNear(side, amount) {
          state.score += amount;
          const p = players[side];
          addFloat(side, p.x, p.y - 18, `+${amount} NEAR`, "#ffe58f");
          blip(960, 0.05, "triangle", 0.03);
        }

        function burst(side, x, y, color, count, speed) {
          for (let i = 0; i < count; i++) {
            const a = Math.random() * Math.PI * 2;
            const sp = randRange(speed * 0.2, speed);
            particles.push({
              side,
              x,
              y,
              vx: Math.cos(a) * sp,
              vy: Math.sin(a) * sp,
              life: randRange(0.18, 0.52),
              maxLife: 1,
              size: randRange(1.5, 3.5),
              color,
            });
          }
          if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
        }

        function collisionAndNearMiss() {
          for (let i = 0; i < hazards.length; i++) {
            const h = hazards[i];
            if (h.phase !== "active") continue;
            const p = players[h.side];
            if (h.kind === "dart") {
              const d = dist(p.x, p.y, h.x, h.y);
              const hitR = p.r + h.r;
              if (d <= hitR) {
                burst(h.side, p.x, p.y, "#ff4b75", 26, 300);
                endRun(h.side, "Neon Dart");
                return;
              }
              if (!h.nearAwarded && d > hitR + 2 && d <= hitR + 18) {
                h.nearAwarded = true;
                awardNear(h.side, 6);
              }
            } else {
              const half = h.width * 0.5;
              if (h.vertical) {
                if (h.pos < -h.width || h.pos > ARENA_W + h.width) continue;
                const d = Math.abs(p.x - h.pos);
                if (d <= half) {
                  burst(h.side, p.x, p.y, "#ff4b75", 26, 300);
                  endRun(h.side, "Laser Sweep");
                  return;
                }
                if (!h.nearAwarded && d > half + 2 && d <= half + 16) {
                  h.nearAwarded = true;
                  awardNear(h.side, 8);
                }
              } else {
                if (h.pos < -h.width || h.pos > PLAY_H + h.width) continue;
                const d = Math.abs(p.y - h.pos);
                if (d <= half) {
                  burst(h.side, p.x, p.y, "#ff4b75", 26, 300);
                  endRun(h.side, "Laser Sweep");
                  return;
                }
                if (!h.nearAwarded && d > half + 2 && d <= half + 16) {
                  h.nearAwarded = true;
                  awardNear(h.side, 8);
                }
              }
            }
          }
        }

        function updateParticles(dt) {
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life -= dt;
            if (p.life <= 0) {
              particles.splice(i, 1);
              continue;
            }
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= 0.96;
            p.vy *= 0.96;
          }
        }

        function updateFloatTexts(dt) {
          for (let i = floatTexts.length - 1; i >= 0; i--) {
            const f = floatTexts[i];
            f.life -= dt;
            if (f.life <= 0) {
              floatTexts.splice(i, 1);
              continue;
            }
            f.y += f.vy * dt;
          }
        }

        function update(dt) {
          state.time += dt;
          if (state.mode === "running") {
            const tuning = currentTuning();
            state.riftCooldown = Math.max(0, state.riftCooldown - dt);
            state.pulseFlash = Math.max(0, state.pulseFlash - dt);

            updatePlayers(dt);
            spawnHazards(dt, tuning);
            updateHazards(dt);
            collisionAndNearMiss();

            // If a collision ended the run, skip score/time gain in this frame.
            if (state.mode === "running") {
              state.timeSurvived += dt;
              state.score += dt;
              if (Math.random() < 0.13 && players[0].dashFx > 0) burst(0, players[0].x, players[0].y, "#82f7ff", 1, 40);
              if (Math.random() < 0.13 && players[1].dashFx > 0) burst(1, players[1].x, players[1].y, "#ff97f2", 1, 40);
            }
          }
          updateParticles(dt);
          updateFloatTexts(dt);
          updateRiftButton();
        }

        function drawWorldGrid(side) {
          const x0 = side * ARENA_W;
          const gridW = ARENA_W;
          const scrollA = (state.time * 46) % 34;
          const scrollB = (state.time * 22) % 34;

          ctx.save();
          ctx.beginPath();
          ctx.rect(x0, PLAY_TOP, gridW, PLAY_H);
          ctx.clip();

          ctx.fillStyle = side === 0 ? "rgba(9,20,34,0.78)" : "rgba(20,9,28,0.78)";
          ctx.fillRect(x0, PLAY_TOP, gridW, PLAY_H);

          ctx.strokeStyle = side === 0 ? "rgba(66,232,255,0.17)" : "rgba(255,77,227,0.16)";
          ctx.lineWidth = 1;
          for (let x = x0 - 34 + scrollA; x <= x0 + gridW + 34; x += 34) {
            ctx.beginPath();
            ctx.moveTo(x, PLAY_TOP);
            ctx.lineTo(x, PLAY_BOTTOM);
            ctx.stroke();
          }
          for (let y = PLAY_TOP - 34 + scrollB; y <= PLAY_BOTTOM + 34; y += 34) {
            ctx.beginPath();
            ctx.moveTo(x0, y);
            ctx.lineTo(x0 + gridW, y);
            ctx.stroke();
          }

          ctx.restore();
        }

        function drawArenas() {
          drawWorldGrid(0);
          drawWorldGrid(1);

          ctx.save();
          ctx.strokeStyle = "rgba(201, 239, 255, 0.2)";
          ctx.lineWidth = 2;
          ctx.strokeRect(1, PLAY_TOP + 1, ARENA_W - 2, PLAY_H - 2);
          ctx.strokeRect(ARENA_W + 1, PLAY_TOP + 1, ARENA_W - 2, PLAY_H - 2);
          ctx.lineWidth = 3;
          ctx.strokeStyle = "rgba(120,210,255,0.32)";
          ctx.beginPath();
          ctx.moveTo(ARENA_W, PLAY_TOP);
          ctx.lineTo(ARENA_W, PLAY_BOTTOM);
          ctx.stroke();
          ctx.restore();
        }

        function drawDart(h) {
          const ax = h.side * ARENA_W;
          const x = ax + h.x;
          const y = PLAY_TOP + h.y;
          if (h.phase === "telegraph") {
            const blink = 0.5 + 0.5 * Math.sin(state.time * 13 + h.id);
            ctx.save();
            ctx.setLineDash([9, 8]);
            ctx.lineWidth = 2;
            ctx.strokeStyle = `rgba(128, 246, 255, ${0.24 + 0.52 * blink})`;
            ctx.beginPath();
            ctx.moveTo(ax + h.startX, PLAY_TOP + h.startY);
            ctx.lineTo(ax + h.startX + h.dirX * 1150, PLAY_TOP + h.startY + h.dirY * 1150);
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.globalAlpha = 0.6 + 0.3 * blink;
            ctx.fillStyle = "rgba(128,246,255,0.9)";
            ctx.beginPath();
            ctx.arc(ax + h.startX, PLAY_TOP + h.startY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else {
            const cool = h.phase === "cooldown" ? clamp(h.timer / h.cooldown, 0, 1) : 1;
            ctx.save();
            ctx.globalAlpha = cool;
            ctx.strokeStyle = "rgba(111,246,255,0.55)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - h.dirX * 18, y - h.dirY * 18);
            ctx.stroke();
            ctx.fillStyle = "rgba(143,255,255,0.95)";
            ctx.shadowBlur = 18;
            ctx.shadowColor = "rgba(111,246,255,0.9)";
            ctx.beginPath();
            ctx.arc(x, y, h.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        function drawLaser(h) {
          const ax = h.side * ARENA_W;
          const blink = 0.5 + 0.5 * Math.sin(state.time * 14 + h.id * 0.77);
          const phaseAlpha =
            h.phase === "telegraph"
              ? 0.25 + 0.42 * blink
              : h.phase === "active"
                ? 0.95
                : clamp(h.timer / h.cooldown, 0, 1) * 0.5;
          const width = h.phase === "active" ? h.width : 4;

          ctx.save();
          ctx.globalAlpha = phaseAlpha;
          ctx.strokeStyle = h.phase === "active" ? "rgba(255, 77, 227, 0.95)" : "rgba(255, 136, 239, 0.82)";
          ctx.lineWidth = width;
          ctx.setLineDash(h.phase === "telegraph" ? [12, 10] : []);
          ctx.shadowBlur = h.phase === "active" ? 18 : 0;
          ctx.shadowColor = "rgba(255,77,227,0.9)";
          ctx.beginPath();
          if (h.vertical) {
            const x = ax + h.pos;
            ctx.moveTo(x, PLAY_TOP);
            ctx.lineTo(x, PLAY_BOTTOM);
          } else {
            const y = PLAY_TOP + h.pos;
            ctx.moveTo(ax, y);
            ctx.lineTo(ax + ARENA_W, y);
          }
          ctx.stroke();
          ctx.restore();

          if (h.phase === "active") {
            ctx.save();
            ctx.globalAlpha = 0.75;
            ctx.strokeStyle = "rgba(255, 244, 253, 0.92)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (h.vertical) {
              const x = ax + h.pos;
              ctx.moveTo(x, PLAY_TOP);
              ctx.lineTo(x, PLAY_BOTTOM);
            } else {
              const y = PLAY_TOP + h.pos;
              ctx.moveTo(ax, y);
              ctx.lineTo(ax + ARENA_W, y);
            }
            ctx.stroke();
            ctx.restore();
          }
        }

        function drawHazards() {
          for (let i = 0; i < hazards.length; i++) {
            const h = hazards[i];
            if (h.kind === "dart") drawDart(h);
            else drawLaser(h);
          }
        }

        function drawParticles() {
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            const a = clamp(p.life * 2.2, 0, 1);
            const wx = p.side * ARENA_W + p.x;
            const wy = PLAY_TOP + p.y;
            ctx.save();
            ctx.globalAlpha = a;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(wx, wy, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        function drawPlayers() {
          for (let side = 0; side < 2; side++) {
            const p = players[side];
            const wx = side * ARENA_W + p.x;
            const wy = PLAY_TOP + p.y;
            ctx.save();
            ctx.shadowBlur = 24;
            ctx.shadowColor = p.color;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(wx, wy, p.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(240,250,255,0.95)";
            ctx.beginPath();
            ctx.arc(wx, wy, p.r + 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            if (p.dashFx > 0) {
              const a = clamp(p.dashFx / 0.16, 0, 1);
              ctx.save();
              ctx.globalAlpha = a * 0.8;
              ctx.strokeStyle = p.color;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(wx, wy, p.r + 9 + (1 - a) * 9, 0, Math.PI * 2);
              ctx.stroke();
              ctx.restore();
            }

            if (p.dashCd > 0) {
              const pct = clamp(1 - p.dashCd / DASH_CD, 0, 1);
              ctx.save();
              ctx.strokeStyle = "rgba(255,255,255,0.36)";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(wx, wy, p.r + 12, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * pct);
              ctx.stroke();
              ctx.restore();
            }
          }
        }

        function drawFloatTexts() {
          ctx.save();
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = "bold 15px ui-monospace, monospace";
          for (let i = 0; i < floatTexts.length; i++) {
            const f = floatTexts[i];
            const wx = f.side * ARENA_W + f.x;
            const wy = PLAY_TOP + f.y;
            ctx.globalAlpha = clamp(f.life / 0.85, 0, 1);
            ctx.fillStyle = f.color;
            ctx.fillText(f.text, wx, wy);
          }
          ctx.restore();
        }

        function drawRiftFlash() {
          if (state.pulseFlash <= 0) return;
          const a = clamp(state.pulseFlash / 0.25, 0, 1);
          const left = players[0];
          const right = players[1];
          const lx = left.x;
          const ly = PLAY_TOP + left.y;
          const rx = ARENA_W + right.x;
          const ry = PLAY_TOP + right.y;

          ctx.save();
          ctx.globalAlpha = a * 0.75;
          ctx.strokeStyle = "rgba(177, 142, 255, 0.9)";
          ctx.lineWidth = 4;
          ctx.setLineDash([10, 8]);
          ctx.beginPath();
          ctx.moveTo(lx, ly);
          ctx.lineTo(rx, ry);
          ctx.stroke();
          ctx.restore();

          ctx.save();
          ctx.globalAlpha = a * 0.22;
          ctx.fillStyle = "rgba(177,142,255,0.85)";
          ctx.fillRect(0, PLAY_TOP, WORLD_W, PLAY_H);
          ctx.restore();
        }

        function drawJoysticks() {
          if (state.mode !== "running") return;
          for (let side = 0; side < 2; side++) {
            const j = joysticks[side];
            const show = touchUi || j.active;
            if (!show) continue;
            if (!j.active) {
              j.baseX = side === 0 ? 112 : WORLD_W - 112;
              j.baseY = WORLD_H - 100;
              j.x = j.baseX;
              j.y = j.baseY;
            }
            ctx.save();
            ctx.globalAlpha = j.active ? 0.58 : 0.22;
            ctx.strokeStyle = side === 0 ? "rgba(70,234,255,0.86)" : "rgba(255,88,228,0.86)";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(j.baseX, j.baseY, JOYSTICK_R, 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalAlpha = j.active ? 0.82 : 0.32;
            ctx.fillStyle = side === 0 ? "rgba(70,234,255,0.85)" : "rgba(255,88,228,0.85)";
            ctx.beginPath();
            ctx.arc(j.x, j.y, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        function drawHud() {
          const score = Math.floor(state.score);
          const time = state.timeSurvived;
          const tier = state.difficultyTier;
          const rift = state.riftCooldown <= 0 ? "READY" : `${state.riftCooldown.toFixed(1)}s`;

          ctx.save();
          ctx.fillStyle = "rgba(6, 12, 25, 0.88)";
          ctx.fillRect(0, 0, WORLD_W, HUD_H);
          ctx.strokeStyle = "rgba(130, 210, 255, 0.32)";
          ctx.lineWidth = 2;
          ctx.strokeRect(0, 0, WORLD_W, HUD_H);

          ctx.font = "bold 20px ui-monospace, monospace";
          ctx.textBaseline = "middle";
          ctx.textAlign = "left";
          ctx.fillStyle = "#dff7ff";
          ctx.fillText(`Score ${score}`, 16, 24);
          ctx.fillStyle = "#b3e8ff";
          ctx.fillText(`Best ${state.best | 0}`, 16, 52);

          ctx.textAlign = "center";
          ctx.fillStyle = "#ffd2f8";
          ctx.fillText(`Time ${time.toFixed(1)}s`, WORLD_W * 0.5, 24);
          ctx.fillStyle = "#f2b6ff";
          ctx.fillText(`Rift ${rift}`, WORLD_W * 0.5, 52);

          ctx.textAlign = "right";
          ctx.fillStyle = "#cbff9e";
          ctx.fillText(`Tier ${tier}`, WORLD_W - 16, 24);
          ctx.fillStyle = "#b0f8ff";
          ctx.fillText("Neon Rift Split", WORLD_W - 16, 52);
          ctx.restore();
        }

        function draw() {
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.clearRect(0, 0, viewW, viewH);
          ctx.fillStyle = "#04070f";
          ctx.fillRect(0, 0, viewW, viewH);

          ctx.save();
          ctx.translate(offX, offY);
          ctx.scale(scale, scale);

          drawArenas();
          drawHazards();
          drawParticles();
          drawPlayers();
          drawRiftFlash();
          drawFloatTexts();
          drawJoysticks();
          drawHud();

          ctx.restore();
        }

        // ===== Input =====
        window.addEventListener("keydown", (e) => {
          if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
          keys.add(e.code);

          if (state.mode === "start") {
            if ((e.code === "Enter" || e.code === "Space") && !e.repeat) {
              startRun();
            }
            return;
          }
          if (state.mode === "gameover") {
            if ((e.code === "Enter" || e.code === "KeyR") && !e.repeat) startRun();
            return;
          }
          if (state.mode === "running") {
            if (e.code === "Space" && !e.repeat) {
              triggerRiftPulse();
            }
          }
        });

        window.addEventListener("keyup", (e) => {
          keys.delete(e.code);
        });

        canvas.addEventListener(
          "pointerdown",
          (e) => {
            if (state.mode !== "running") return;
            if (e.pointerType === "mouse") return;
            touchUi = true;
            if (e.cancelable) e.preventDefault();
            const p = pointerToWorld(e.clientX, e.clientY);
            if (!p.inside) return;
            const side = p.x < ARENA_W ? 0 : 1;
            const j = joysticks[side];
            if (j.active) return;
            j.active = true;
            j.id = e.pointerId;
            const minX = side === 0 ? 36 : ARENA_W + 36;
            const maxX = side === 0 ? ARENA_W - 36 : WORLD_W - 36;
            j.baseX = clamp(p.x, minX, maxX);
            j.baseY = clamp(p.y, PLAY_TOP + 52, WORLD_H - 34);
            j.x = j.baseX;
            j.y = j.baseY;
            j.dx = 0;
            j.dy = 0;
            const now = performance.now();
            if (now - j.lastTap <= 300) {
              j.lastTap = 0;
              triggerDash(side);
            } else {
              j.lastTap = now;
            }
            try {
              canvas.setPointerCapture(e.pointerId);
            } catch (_) {}
          },
          { passive: false }
        );

        canvas.addEventListener(
          "pointermove",
          (e) => {
            if (state.mode !== "running") return;
            for (let side = 0; side < 2; side++) {
              const j = joysticks[side];
              if (!j.active || j.id !== e.pointerId) continue;
              if (e.cancelable) e.preventDefault();
              const p = pointerToWorld(e.clientX, e.clientY);
              const dx = p.x - j.baseX;
              const dy = p.y - j.baseY;
              const l = Math.hypot(dx, dy);
              const k = l > JOYSTICK_R ? JOYSTICK_R / l : 1;
              j.x = j.baseX + dx * k;
              j.y = j.baseY + dy * k;
              j.dx = (dx * k) / JOYSTICK_R;
              j.dy = (dy * k) / JOYSTICK_R;
              break;
            }
          },
          { passive: false }
        );

        function releasePointer(pointerId) {
          for (let side = 0; side < 2; side++) {
            const j = joysticks[side];
            if (!j.active || j.id !== pointerId) continue;
            j.active = false;
            j.id = null;
            j.dx = 0;
            j.dy = 0;
          }
        }

        canvas.addEventListener(
          "pointerup",
          (e) => {
            if (e.cancelable) e.preventDefault();
            releasePointer(e.pointerId);
          },
          { passive: false }
        );
        canvas.addEventListener(
          "pointercancel",
          (e) => {
            if (e.cancelable) e.preventDefault();
            releasePointer(e.pointerId);
          },
          { passive: false }
        );

        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            keys.clear();
            resetJoystick(0);
            resetJoystick(1);
          }
        });

        // ===== UI events =====
        soundBtn.addEventListener("click", () => {
          ensureAudio();
          toggleSound();
        });
        startSoundBtn.addEventListener("click", () => {
          ensureAudio();
          toggleSound();
        });
        startBtn.addEventListener("click", () => startRun());
        restartBtn.addEventListener("click", () => startRun());
        riftBtn.addEventListener("click", () => {
          ensureAudio();
          triggerRiftPulse();
        });

        window.addEventListener("resize", resize);
        window.addEventListener(
          "pointerdown",
          () => {
            ensureAudio();
          },
          { once: true }
        );
        window.addEventListener(
          "keydown",
          () => {
            ensureAudio();
          },
          { once: true }
        );

        // ===== Main loop =====
        let last = performance.now();
        function frame(now) {
          const dt = Math.min(0.033, Math.max(0.001, (now - last) / 1000));
          last = now;
          update(dt);
          draw();
          requestAnimationFrame(frame);
        }

        // boot
        syncSoundLabels();
        refreshStartStats();
        resize();
        updateRiftButton();
        requestAnimationFrame(frame);
      })();
    </script>
  </body>
</html>
