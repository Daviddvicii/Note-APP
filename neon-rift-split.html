<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#05060f" />
    <title>Neon Rift Split</title>
    <style>
      :root {
        --bg: #05060f;
        --ink: #d8edff;
        --cyan: #00e8ff;
        --pink: #ff3ce1;
        --lime: #96ff3c;
        --panel: rgba(7, 11, 26, 0.74);
        --border: rgba(120, 214, 255, 0.32);
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        background: radial-gradient(circle at 50% 30%, #09111f 0%, #03040a 65%);
        color: var(--ink);
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        touch-action: none;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #gameShell {
        position: relative;
        width: 900px;
        height: 600px;
        max-width: 100vw;
        max-height: 100vh;
        border: 1px solid rgba(0, 255, 255, 0.2);
        box-shadow: 0 0 50px rgba(0, 220, 255, 0.15), inset 0 0 30px rgba(255, 0, 240, 0.07);
        background: #05060f;
        overflow: hidden;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .scanlines,
      .crt-flicker {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .scanlines {
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.02) 0%,
          rgba(255, 255, 255, 0.02) 50%,
          rgba(0, 0, 0, 0.2) 50%,
          rgba(0, 0, 0, 0.2) 100%
        );
        background-size: 100% 4px;
        opacity: 0.5;
        z-index: 10;
      }

      .crt-flicker {
        background: rgba(15, 11, 26, 0.12);
        animation: crt-flicker 0.15s infinite;
        z-index: 11;
      }

      @keyframes crt-flicker {
        0% {
          opacity: 0.08;
        }
        40% {
          opacity: 0.14;
        }
        100% {
          opacity: 0.1;
        }
      }

      #hud {
        position: absolute;
        top: 8px;
        left: 10px;
        right: 10px;
        z-index: 20;
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
        pointer-events: none;
      }

      .chip {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--panel);
        backdrop-filter: blur(4px);
        text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        font-size: 13px;
        letter-spacing: 0.02em;
        white-space: nowrap;
      }

      #hudScore {
        color: var(--cyan);
      }

      #hudBest {
        color: #ffc2ff;
      }

      #hudTier {
        color: var(--lime);
      }

      .action-btn {
        pointer-events: auto;
        border: 1px solid var(--border);
        background: rgba(4, 11, 26, 0.88);
        color: #eaf7ff;
        border-radius: 999px;
        padding: 7px 12px;
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.04em;
        cursor: pointer;
        text-transform: uppercase;
        box-shadow: 0 0 10px rgba(0, 230, 255, 0.2);
        transition: transform 0.12s ease, box-shadow 0.12s ease, opacity 0.12s ease;
      }

      .action-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 0 16px rgba(0, 230, 255, 0.45);
      }

      .action-btn:disabled {
        opacity: 0.45;
        cursor: default;
        transform: none;
      }

      #riftBtn {
        margin-left: auto;
      }

      #touchControls {
        position: absolute;
        inset: 0;
        z-index: 24;
        pointer-events: none;
      }

      #touchControls.hidden,
      #touchControls.inactive {
        display: none;
      }

      .joystick-zone {
        position: absolute;
        top: 64px;
        bottom: 0;
        width: 50%;
        pointer-events: auto;
        touch-action: none;
      }

      .joystick-zone.left {
        left: 0;
      }

      .joystick-zone.right {
        right: 0;
      }

      .joy-base {
        position: absolute;
        width: 92px;
        height: 92px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.35);
        background: rgba(14, 22, 45, 0.35);
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        transform: translate(-50%, -50%);
        display: none;
      }

      .joy-base.active {
        display: block;
      }

      .joy-knob {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 42px;
        height: 42px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 25%, #ffffff 0%, #8deaff 30%, #2a6cff 100%);
        transform: translate(-50%, -50%);
        box-shadow: 0 0 10px rgba(0, 240, 255, 0.75);
      }

      .overlay {
        position: absolute;
        inset: 0;
        z-index: 30;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(3, 4, 10, 0.88);
        padding: 18px;
        text-align: center;
        backdrop-filter: blur(3px);
      }

      .overlay.hidden {
        display: none;
      }

      h1 {
        margin: 0 0 12px;
        font-size: clamp(28px, 6vw, 56px);
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: #e2f7ff;
        text-shadow: 0 0 18px rgba(0, 255, 255, 0.65), 0 0 32px rgba(255, 45, 220, 0.45);
      }

      .subtitle {
        font-size: clamp(13px, 2.2vw, 18px);
        color: #cae5ff;
        max-width: 720px;
        line-height: 1.5;
        margin: 4px 0;
      }

      .controls-grid {
        margin: 18px 0 6px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        width: min(640px, 100%);
      }

      .controls-grid .cell {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(139, 219, 255, 0.2);
        background: rgba(9, 15, 30, 0.7);
        font-size: 13px;
        line-height: 1.4;
      }

      .controls-grid b {
        display: block;
        margin-bottom: 4px;
        color: #7effe7;
      }

      .main-btn {
        margin-top: 18px;
        padding: 13px 26px;
        border-radius: 10px;
        border: 1px solid rgba(94, 232, 255, 0.55);
        background: linear-gradient(130deg, rgba(0, 129, 181, 0.45), rgba(123, 36, 194, 0.45));
        color: #ebfeff;
        font-size: 17px;
        font-weight: 700;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 0 16px rgba(0, 245, 255, 0.3);
      }

      .main-btn:hover {
        filter: brightness(1.1);
      }

      .result-lines {
        margin-top: 10px;
        font-size: 18px;
        line-height: 1.8;
      }

      .result-lines b {
        color: #9dfff5;
      }

      .hint {
        margin-top: 8px;
        font-size: 12px;
        color: rgba(220, 234, 255, 0.8);
      }

      @media (max-width: 820px) {
        #hud {
          top: 6px;
          left: 6px;
          right: 6px;
          gap: 6px;
        }

        .chip {
          padding: 5px 9px;
          font-size: 12px;
        }

        .action-btn {
          padding: 6px 10px;
          font-size: 11px;
        }

        .controls-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameShell">
      <canvas id="gameCanvas" width="900" height="600"></canvas>
      <div class="scanlines"></div>
      <div class="crt-flicker"></div>

      <div id="hud">
        <div class="chip" id="hudScore">Score 0.0</div>
        <div class="chip" id="hudBest">Best 0.0</div>
        <div class="chip" id="hudTime">Time 0.0s</div>
        <div class="chip" id="hudTier">Tier 1</div>
        <button class="action-btn" id="riftBtn" type="button">RIFT READY</button>
        <button class="action-btn" id="soundBtn" type="button">Sound ON</button>
      </div>

      <div id="touchControls" class="inactive">
        <div class="joystick-zone left" data-player="left">
          <div class="joy-base">
            <div class="joy-knob"></div>
          </div>
        </div>
        <div class="joystick-zone right" data-player="right">
          <div class="joy-base">
            <div class="joy-knob"></div>
          </div>
        </div>
      </div>

      <div id="startScreen" class="overlay">
        <h1>Neon Rift Split</h1>
        <div class="subtitle">Control two avatars at once. If either one dies, the run ends.</div>
        <div class="controls-grid">
          <div class="cell">
            <b>Desktop</b>
            Left: WASD<br />
            Right: Arrow Keys<br />
            Space: Rift Pulse (swap positions)
          </div>
          <div class="cell">
            <b>Mobile</b>
            Left half joystick controls left avatar<br />
            Right half joystick controls right avatar<br />
            Double tap a side to dash that avatar
          </div>
        </div>
        <div class="subtitle">Dodge telegraphed hazards. Near-miss dodges grant score bonus.</div>
        <button id="startBtn" class="main-btn" type="button">Start Run</button>
        <div class="hint">MVP: dodge-only survival Â· Rift cooldown: 6s</div>
      </div>

      <div id="gameOverScreen" class="overlay hidden">
        <h1>Run Over</h1>
        <div class="subtitle">Attention split failed. Try another run.</div>
        <div class="result-lines">
          Time: <b id="finalTime">0.0s</b><br />
          Score: <b id="finalScore">0.0</b><br />
          Best: <b id="finalBest">0.0</b>
        </div>
        <button id="restartBtn" class="main-btn" type="button">Restart</button>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        // World and arena dimensions
        const WORLD_W = 900;
        const WORLD_H = 600;
        const ARENA_W = WORLD_W / 2;
        const PLAY_TOP = 56;
        const PLAY_BOTTOM = WORLD_H - 8;

        const PLAYER_RADIUS = 11;
        const PLAYER_ACCEL = 1250;
        const PLAYER_MAX_SPEED = 260;
        const PLAYER_DRAG = 8;

        const DASH_SPEED = 630;
        const DASH_TIME = 0.16;
        const DASH_COOLDOWN = 0.55;

        const RIFT_COOLDOWN = 6;
        const MAX_HAZARDS_PER_ARENA = 30;

        const BEST_KEY = "neon-rift-best";
        const SOUND_KEY = "neon-rift-sound";
        const TOTAL_RUNS_KEY = "neon-rift-total-runs";
        const BEST_TIME_KEY = "neon-rift-best-time";

        const shell = document.getElementById("gameShell");
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const hudScore = document.getElementById("hudScore");
        const hudBest = document.getElementById("hudBest");
        const hudTime = document.getElementById("hudTime");
        const hudTier = document.getElementById("hudTier");

        const riftBtn = document.getElementById("riftBtn");
        const soundBtn = document.getElementById("soundBtn");

        const touchControls = document.getElementById("touchControls");
        const startScreen = document.getElementById("startScreen");
        const gameOverScreen = document.getElementById("gameOverScreen");
        const startBtn = document.getElementById("startBtn");
        const restartBtn = document.getElementById("restartBtn");

        const finalTime = document.getElementById("finalTime");
        const finalScore = document.getElementById("finalScore");
        const finalBest = document.getElementById("finalBest");

        const keysDown = new Set();
        const isTouchDevice = window.matchMedia("(pointer: coarse)").matches || "ontouchstart" in window;

        let gameState = "start"; // start | playing | gameover
        let elapsed = 0;
        let score = 0;
        let riftCooldown = 0;
        let gridScroll = 0;
        let pulseFlash = 0;
        let lastFrame = performance.now();

        let bestScore = readNumber(BEST_KEY, 0);
        let bestTime = readNumber(BEST_TIME_KEY, 0);
        let totalRuns = readNumber(TOTAL_RUNS_KEY, 0);
        let soundOn = readString(SOUND_KEY, "1") !== "0";

        let audioCtx = null;

        let hazardId = 1;
        const hazards = [];
        const spawnTimers = [0, 0];
        const spawnTargets = [1.1, 1.4];

        const players = {
          left: createPlayer("left", 0, "#00ebff"),
          right: createPlayer("right", 1, "#ff52f3"),
        };

        const joystickState = {
          left: { x: 0, y: 0 },
          right: { x: 0, y: 0 },
        };

        const joysticks = {
          left: initJoystick(document.querySelector('.joystick-zone.left'), "left"),
          right: initJoystick(document.querySelector('.joystick-zone.right'), "right"),
        };

        if (!isTouchDevice) {
          touchControls.classList.add("hidden");
        }

        updateSoundLabel();
        updateHud();
        resizeCanvasCss();
        resetRun();
        draw();
        requestAnimationFrame(frame);

        // -------------------- Main loop --------------------
        function frame(now) {
          const dt = Math.min(0.05, Math.max(0.001, (now - lastFrame) / 1000));
          lastFrame = now;

          if (gameState === "playing") {
            updateGame(dt);
          } else {
            gridScroll = (gridScroll + dt * 34) % 80;
          }

          draw();
          requestAnimationFrame(frame);
        }

        function updateGame(dt) {
          elapsed += dt;
          score += dt;
          gridScroll = (gridScroll + dt * 82) % 80;
          pulseFlash = Math.max(0, pulseFlash - dt * 2.4);
          riftCooldown = Math.max(0, riftCooldown - dt);

          updatePlayers(dt);
          spawnHazards(dt);
          updateHazards(dt);
          handleCollisions();
          updateHud();
        }

        // -------------------- Player system --------------------
        function createPlayer(id, arena, color) {
          return {
            id,
            arena,
            color,
            x: ARENA_W * (arena === 0 ? 0.36 : 0.64),
            y: (PLAY_TOP + PLAY_BOTTOM) * 0.5,
            vx: 0,
            vy: 0,
            radius: PLAYER_RADIUS,
            alive: true,
            dashTimer: 0,
            dashCooldown: 0,
            dashVX: 0,
            dashVY: 0,
            lastDirX: 0,
            lastDirY: -1,
          };
        }

        function resetPlayer(player) {
          player.x = ARENA_W * (player.arena === 0 ? 0.36 : 0.64);
          player.y = (PLAY_TOP + PLAY_BOTTOM) * 0.5;
          player.vx = 0;
          player.vy = 0;
          player.alive = true;
          player.dashTimer = 0;
          player.dashCooldown = 0;
          player.dashVX = 0;
          player.dashVY = 0;
          player.lastDirX = 0;
          player.lastDirY = -1;
        }

        function getInputForPlayer(player) {
          let x = 0;
          let y = 0;

          if (player.id === "left") {
            if (keysDown.has("KeyA")) x -= 1;
            if (keysDown.has("KeyD")) x += 1;
            if (keysDown.has("KeyW")) y -= 1;
            if (keysDown.has("KeyS")) y += 1;
          } else {
            if (keysDown.has("ArrowLeft")) x -= 1;
            if (keysDown.has("ArrowRight")) x += 1;
            if (keysDown.has("ArrowUp")) y -= 1;
            if (keysDown.has("ArrowDown")) y += 1;
          }

          x += joystickState[player.id].x;
          y += joystickState[player.id].y;

          const mag = Math.hypot(x, y);
          if (mag > 1) {
            x /= mag;
            y /= mag;
          }
          return { x, y, mag: Math.hypot(x, y) };
        }

        function updatePlayers(dt) {
          updateOnePlayer(players.left, dt);
          updateOnePlayer(players.right, dt);
        }

        function updateOnePlayer(player, dt) {
          if (!player.alive) return;

          player.dashCooldown = Math.max(0, player.dashCooldown - dt);
          const input = getInputForPlayer(player);

          if (input.mag > 0.03) {
            player.lastDirX = input.x;
            player.lastDirY = input.y;
          }

          if (player.dashTimer > 0) {
            player.dashTimer -= dt;
            player.x += player.dashVX * dt;
            player.y += player.dashVY * dt;
            if (player.dashTimer <= 0) {
              player.vx = player.dashVX * 0.25;
              player.vy = player.dashVY * 0.25;
            }
          } else {
            player.vx += input.x * PLAYER_ACCEL * dt;
            player.vy += input.y * PLAYER_ACCEL * dt;

            const speed = Math.hypot(player.vx, player.vy);
            if (speed > PLAYER_MAX_SPEED) {
              const s = PLAYER_MAX_SPEED / speed;
              player.vx *= s;
              player.vy *= s;
            }

            const drag = Math.exp(-PLAYER_DRAG * dt);
            player.vx *= drag;
            player.vy *= drag;

            player.x += player.vx * dt;
            player.y += player.vy * dt;
          }

          clampPlayerToArena(player);
        }

        function clampPlayerToArena(player) {
          const minX = player.radius;
          const maxX = ARENA_W - player.radius;
          const minY = PLAY_TOP + player.radius;
          const maxY = PLAY_BOTTOM - player.radius;

          if (player.x < minX) {
            player.x = minX;
            player.vx = 0;
          } else if (player.x > maxX) {
            player.x = maxX;
            player.vx = 0;
          }

          if (player.y < minY) {
            player.y = minY;
            player.vy = 0;
          } else if (player.y > maxY) {
            player.y = maxY;
            player.vy = 0;
          }
        }

        function triggerDash(player) {
          if (gameState !== "playing" || !player.alive || player.dashCooldown > 0) return;

          let dx = player.lastDirX;
          let dy = player.lastDirY;
          const input = getInputForPlayer(player);
          if (input.mag > 0.04) {
            dx = input.x;
            dy = input.y;
          }

          const mag = Math.hypot(dx, dy);
          if (mag < 0.01) {
            dx = 0;
            dy = -1;
          } else {
            dx /= mag;
            dy /= mag;
          }

          player.dashVX = dx * DASH_SPEED;
          player.dashVY = dy * DASH_SPEED;
          player.dashTimer = DASH_TIME;
          player.dashCooldown = DASH_COOLDOWN;
          playBeep(player.id === "left" ? 690 : 760, 0.07, "square", 0.045);
        }

        // -------------------- Hazard system --------------------
        function spawnHazards(dt) {
          for (let arena = 0; arena < 2; arena += 1) {
            spawnTimers[arena] += dt;
            if (spawnTimers[arena] < spawnTargets[arena]) continue;

            spawnTimers[arena] = 0;
            spawnTargets[arena] = getNextSpawnInterval(arena);

            if (hazardsInArena(arena) >= MAX_HAZARDS_PER_ARENA) continue;
            spawnOneHazard(arena);
          }
        }

        function getNextSpawnInterval(arena) {
          const base = clamp(1.45 - elapsed * 0.026, 0.4, 1.45);
          const bias = arena === 0 ? 0.96 : 1.04;
          return base * bias * (0.72 + Math.random() * 0.6);
        }

        function hazardsInArena(arena) {
          let n = 0;
          for (const h of hazards) {
            if (h.arena === arena) n += 1;
          }
          return n;
        }

        function spawnOneHazard(arena) {
          const laserChance = clamp(0.25 + elapsed * 0.01, 0.25, 0.58);
          if (Math.random() < laserChance) {
            spawnLaserSweep(arena);
          } else {
            spawnNeonDart(arena);
          }
        }

        function telegraphScale() {
          return clamp(1 - elapsed * 0.015, 0.56, 1);
        }

        function spawnNeonDart(arena) {
          const target = arena === 0 ? players.left : players.right;
          const margin = 14;
          const edge = Math.floor(Math.random() * 4);
          let x = 0;
          let y = 0;

          if (edge === 0) {
            x = rand(margin, ARENA_W - margin);
            y = PLAY_TOP + margin;
          } else if (edge === 1) {
            x = ARENA_W - margin;
            y = rand(PLAY_TOP + margin, PLAY_BOTTOM - margin);
          } else if (edge === 2) {
            x = rand(margin, ARENA_W - margin);
            y = PLAY_BOTTOM - margin;
          } else {
            x = margin;
            y = rand(PLAY_TOP + margin, PLAY_BOTTOM - margin);
          }

          let dx = target.x - x;
          let dy = target.y - y;
          const dm = Math.hypot(dx, dy) || 1;
          dx /= dm;
          dy /= dm;

          const end = rayToArenaBounds(x, y, dx, dy);
          hazards.push({
            id: hazardId++,
            type: "dart",
            arena,
            phase: "telegraph",
            timer: 0,
            telegraphDuration: Math.max(0.32, 0.6 * telegraphScale()),
            activeDuration: 3.2,
            cooldownDuration: 0.14,
            startX: x,
            startY: y,
            x,
            y,
            endX: end.x,
            endY: end.y,
            dirX: dx,
            dirY: dy,
            speed: Math.min(820, 320 + elapsed * 12),
            radius: 8,
            nearMiss: false,
          });
        }

        function spawnLaserSweep(arena) {
          const vertical = Math.random() < 0.5;
          const lineMin = vertical ? 20 : PLAY_TOP + 22;
          const lineMax = vertical ? ARENA_W - 20 : PLAY_BOTTOM - 22;
          hazards.push({
            id: hazardId++,
            type: "laser",
            arena,
            phase: "telegraph",
            timer: 0,
            telegraphDuration: Math.max(0.45, 0.9 * telegraphScale()),
            activeDuration: 0.3,
            cooldownDuration: 0.22,
            vertical,
            linePos: rand(lineMin, lineMax),
            sweepSpeed: 110 + elapsed * 7,
            dir: Math.random() < 0.5 ? -1 : 1,
            lineMin,
            lineMax,
            thickness: 13 + Math.min(8, elapsed * 0.17),
            nearMiss: false,
          });
        }

        function rayToArenaBounds(x, y, dx, dy) {
          let t = 2000;
          if (dx > 0) t = Math.min(t, (ARENA_W + 40 - x) / dx);
          if (dx < 0) t = Math.min(t, (-40 - x) / dx);
          if (dy > 0) t = Math.min(t, (PLAY_BOTTOM + 40 - y) / dy);
          if (dy < 0) t = Math.min(t, (PLAY_TOP - 40 - y) / dy);
          if (!Number.isFinite(t)) t = 1000;
          return { x: x + dx * t, y: y + dy * t };
        }

        function updateHazards(dt) {
          for (let i = hazards.length - 1; i >= 0; i -= 1) {
            const h = hazards[i];
            h.timer += dt;

            if (h.phase === "telegraph") {
              if (h.timer >= h.telegraphDuration) {
                h.phase = "active";
                h.timer = 0;
              }
              continue;
            }

            if (h.phase === "active") {
              if (h.type === "dart") {
                h.x += h.dirX * h.speed * dt;
                h.y += h.dirY * h.speed * dt;
                const out =
                  h.x < -45 ||
                  h.x > ARENA_W + 45 ||
                  h.y < PLAY_TOP - 45 ||
                  h.y > PLAY_BOTTOM + 45;
                if (out || h.timer >= h.activeDuration) {
                  h.phase = "cooldown";
                  h.timer = 0;
                }
              } else if (h.type === "laser") {
                h.linePos += h.dir * h.sweepSpeed * dt;
                if (h.linePos <= h.lineMin) {
                  h.linePos = h.lineMin;
                  h.dir = 1;
                } else if (h.linePos >= h.lineMax) {
                  h.linePos = h.lineMax;
                  h.dir = -1;
                }
                if (h.timer >= h.activeDuration) {
                  h.phase = "cooldown";
                  h.timer = 0;
                }
              }
              continue;
            }

            if (h.phase === "cooldown" && h.timer >= h.cooldownDuration) {
              hazards.splice(i, 1);
            }
          }
        }

        function handleCollisions() {
          if (gameState !== "playing") return;

          for (const h of hazards) {
            if (h.phase !== "active") continue;
            const player = h.arena === 0 ? players.left : players.right;
            if (!player.alive) continue;

            if (h.type === "dart") {
              const dist = Math.hypot(player.x - h.x, player.y - h.y);
              const hit = dist <= player.radius + h.radius;
              if (hit) {
                killPlayer(player);
                return;
              }
              if (!h.nearMiss && dist <= player.radius + h.radius + 18) {
                h.nearMiss = true;
                score += 6;
                pulseFlash = Math.max(pulseFlash, 0.22);
                playBeep(1030, 0.045, "triangle", 0.025);
              }
            } else if (h.type === "laser") {
              const dist = h.vertical ? Math.abs(player.x - h.linePos) : Math.abs(player.y - h.linePos);
              const halfThickness = h.thickness * 0.5;
              const hit = dist <= halfThickness + player.radius;
              if (hit) {
                killPlayer(player);
                return;
              }
              if (!h.nearMiss && dist <= halfThickness + player.radius + 8) {
                h.nearMiss = true;
                score += 5;
                pulseFlash = Math.max(pulseFlash, 0.18);
              }
            }
          }
        }

        // -------------------- Rift pulse --------------------
        function useRiftPulse() {
          if (gameState !== "playing" || riftCooldown > 0) return;

          const left = players.left;
          const right = players.right;
          if (!left.alive || !right.alive) return;

          const temp = {
            x: left.x,
            y: left.y,
            vx: left.vx,
            vy: left.vy,
            dashVX: left.dashVX,
            dashVY: left.dashVY,
            dashTimer: left.dashTimer,
            lastDirX: left.lastDirX,
            lastDirY: left.lastDirY,
          };

          left.x = right.x;
          left.y = right.y;
          left.vx = right.vx;
          left.vy = right.vy;
          left.dashVX = right.dashVX;
          left.dashVY = right.dashVY;
          left.dashTimer = right.dashTimer;
          left.lastDirX = right.lastDirX;
          left.lastDirY = right.lastDirY;

          right.x = temp.x;
          right.y = temp.y;
          right.vx = temp.vx;
          right.vy = temp.vy;
          right.dashVX = temp.dashVX;
          right.dashVY = temp.dashVY;
          right.dashTimer = temp.dashTimer;
          right.lastDirX = temp.lastDirX;
          right.lastDirY = temp.lastDirY;

          clampPlayerToArena(left);
          clampPlayerToArena(right);
          riftCooldown = RIFT_COOLDOWN;
          pulseFlash = 0.6;
          playBeep(360, 0.09, "sawtooth", 0.04);
          playBeep(720, 0.08, "triangle", 0.03);
          handleCollisions();
        }

        // -------------------- Drawing --------------------
        function draw() {
          ctx.clearRect(0, 0, WORLD_W, WORLD_H);
          drawArena(0, "#07192c", "#0a223b");
          drawArena(1, "#200a2a", "#351245");
          drawDivider();
          drawHazards();
          drawPlayers();
          drawTopShade();
          drawRiftFlash();
        }

        function drawArena(arena, topColor, bottomColor) {
          const ox = arena * ARENA_W;
          ctx.save();
          ctx.beginPath();
          ctx.rect(ox, 0, ARENA_W, WORLD_H);
          ctx.clip();

          const grad = ctx.createLinearGradient(0, 0, 0, WORLD_H);
          grad.addColorStop(0, topColor);
          grad.addColorStop(1, bottomColor);
          ctx.fillStyle = grad;
          ctx.fillRect(ox, 0, ARENA_W, WORLD_H);

          const sx = (gridScroll * 0.8) % 40;
          const sy = (gridScroll * 0.45) % 28;

          ctx.strokeStyle = arena === 0 ? "rgba(0,255,255,0.11)" : "rgba(255,80,240,0.11)";
          ctx.lineWidth = 1;

          for (let x = ox - 40 + sx; x < ox + ARENA_W + 40; x += 40) {
            ctx.beginPath();
            ctx.moveTo(x, PLAY_TOP);
            ctx.lineTo(x, WORLD_H);
            ctx.stroke();
          }

          for (let y = PLAY_TOP + sy; y < WORLD_H + 28; y += 28) {
            ctx.beginPath();
            ctx.moveTo(ox, y);
            ctx.lineTo(ox + ARENA_W, y);
            ctx.stroke();
          }

          ctx.restore();
        }

        function drawDivider() {
          ctx.save();
          ctx.fillStyle = "rgba(150, 220, 255, 0.07)";
          ctx.fillRect(ARENA_W - 2, 0, 4, WORLD_H);

          ctx.strokeStyle = "rgba(180, 240, 255, 0.4)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(ARENA_W + 0.5, 0);
          ctx.lineTo(ARENA_W + 0.5, WORLD_H);
          ctx.stroke();
          ctx.restore();
        }

        function drawHazards() {
          for (const h of hazards) {
            if (h.type === "dart") {
              drawDart(h);
            } else {
              drawLaser(h);
            }
          }
        }

        function drawDart(h) {
          const ox = h.arena * ARENA_W;
          if (h.phase === "telegraph") {
            const blink = 0.35 + 0.45 * Math.abs(Math.sin(h.timer * 12));
            ctx.save();
            ctx.strokeStyle = `rgba(100, 245, 255, ${blink.toFixed(3)})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(ox + h.startX, h.startY);
            ctx.lineTo(ox + h.endX, h.endY);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = `rgba(130, 255, 255, ${Math.min(1, blink + 0.2).toFixed(3)})`;
            ctx.beginPath();
            ctx.arc(ox + h.startX, h.startY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            return;
          }

          if (h.phase !== "active") return;

          ctx.save();
          ctx.shadowBlur = 18;
          ctx.shadowColor = "#53f6ff";
          ctx.fillStyle = "#d9ffff";
          ctx.beginPath();
          ctx.arc(ox + h.x, h.y, h.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        function drawLaser(h) {
          const ox = h.arena * ARENA_W;
          ctx.save();

          if (h.phase === "telegraph") {
            const phase = Math.sin(h.timer * 16);
            const alpha = phase > 0 ? 0.75 : 0.32;
            ctx.strokeStyle = h.vertical
              ? `rgba(255, 80, 255, ${alpha.toFixed(3)})`
              : `rgba(120, 255, 245, ${alpha.toFixed(3)})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([14, 9]);
          } else if (h.phase === "active") {
            ctx.strokeStyle = h.vertical ? "rgba(255, 110, 245, 0.95)" : "rgba(130, 255, 245, 0.95)";
            ctx.lineWidth = h.thickness;
            ctx.shadowBlur = 16;
            ctx.shadowColor = h.vertical ? "#ff63f1" : "#58fff7";
            ctx.setLineDash([]);
          } else {
            ctx.restore();
            return;
          }

          ctx.beginPath();
          if (h.vertical) {
            ctx.moveTo(ox + h.linePos, PLAY_TOP);
            ctx.lineTo(ox + h.linePos, PLAY_BOTTOM);
          } else {
            ctx.moveTo(ox + 8, h.linePos);
            ctx.lineTo(ox + ARENA_W - 8, h.linePos);
          }
          ctx.stroke();
          ctx.restore();
        }

        function drawPlayers() {
          drawOnePlayer(players.left);
          drawOnePlayer(players.right);
        }

        function drawOnePlayer(player) {
          const ox = player.arena * ARENA_W;
          const x = ox + player.x;
          const y = player.y;

          if (player.dashTimer > 0) {
            const trailLen = 4;
            const dirMag = Math.hypot(player.dashVX, player.dashVY) || 1;
            const tx = player.dashVX / dirMag;
            const ty = player.dashVY / dirMag;
            for (let i = 1; i <= trailLen; i += 1) {
              const alpha = (trailLen - i + 1) / (trailLen * 4.2);
              ctx.fillStyle = `rgba(190, 250, 255, ${alpha.toFixed(3)})`;
              ctx.beginPath();
              ctx.arc(x - tx * i * 10, y - ty * i * 10, player.radius * (1 - i * 0.12), 0, Math.PI * 2);
              ctx.fill();
            }
          }

          ctx.save();
          ctx.shadowBlur = 24;
          ctx.shadowColor = player.color;
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(x, y, player.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.lineWidth = 2;
          ctx.strokeStyle = player.color;
          ctx.beginPath();
          ctx.arc(x, y, player.radius + 3, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        function drawTopShade() {
          const g = ctx.createLinearGradient(0, 0, 0, PLAY_TOP + 22);
          g.addColorStop(0, "rgba(4,6,16,0.92)");
          g.addColorStop(1, "rgba(4,6,16,0)");
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, WORLD_W, PLAY_TOP + 22);
        }

        function drawRiftFlash() {
          if (pulseFlash <= 0) return;
          ctx.fillStyle = `rgba(245, 255, 255, ${(pulseFlash * 0.24).toFixed(3)})`;
          ctx.fillRect(0, 0, WORLD_W, WORLD_H);
        }

        // -------------------- Game state --------------------
        function resetRun() {
          elapsed = 0;
          score = 0;
          riftCooldown = 0;
          gridScroll = 0;
          pulseFlash = 0;
          hazards.length = 0;
          spawnTimers[0] = 0;
          spawnTimers[1] = 0;
          spawnTargets[0] = 0.9;
          spawnTargets[1] = 1.2;

          resetPlayer(players.left);
          resetPlayer(players.right);
          updateHud();
        }

        function startRun() {
          resetRun();
          gameState = "playing";
          startScreen.classList.add("hidden");
          gameOverScreen.classList.add("hidden");
          if (isTouchDevice) {
            touchControls.classList.remove("inactive");
          }
          playBeep(880, 0.07, "square", 0.045);
          playBeep(1120, 0.07, "triangle", 0.025);
        }

        function killPlayer(player) {
          if (gameState !== "playing" || !player.alive) return;
          player.alive = false;
          endRun();
        }

        function endRun() {
          gameState = "gameover";
          touchControls.classList.add("inactive");
          totalRuns += 1;
          writeNumber(TOTAL_RUNS_KEY, totalRuns);

          if (score > bestScore) {
            bestScore = score;
            writeNumber(BEST_KEY, bestScore);
          }
          if (elapsed > bestTime) {
            bestTime = elapsed;
            writeNumber(BEST_TIME_KEY, bestTime);
          }

          finalTime.textContent = `${elapsed.toFixed(1)}s`;
          finalScore.textContent = score.toFixed(1);
          finalBest.textContent = bestScore.toFixed(1);
          updateHud();

          gameOverScreen.classList.remove("hidden");
          playBeep(220, 0.18, "sawtooth", 0.045);
          playBeep(140, 0.22, "triangle", 0.03);
        }

        function getTier() {
          return 1 + Math.floor(elapsed / 20);
        }

        function updateHud() {
          hudScore.textContent = `Score ${score.toFixed(1)}`;
          hudBest.textContent = `Best ${bestScore.toFixed(1)}`;
          hudTime.textContent = `Time ${elapsed.toFixed(1)}s`;
          hudTier.textContent = `Tier ${getTier()}`;

          if (gameState !== "playing") {
            riftBtn.disabled = true;
            riftBtn.textContent = "RIFT READY";
            return;
          }

          if (riftCooldown <= 0) {
            riftBtn.disabled = false;
            riftBtn.textContent = "RIFT READY";
          } else {
            riftBtn.disabled = true;
            riftBtn.textContent = `RIFT ${riftCooldown.toFixed(1)}s`;
          }
        }

        // -------------------- Input --------------------
        window.addEventListener("keydown", (event) => {
          const code = event.code;
          if (
            code === "ArrowUp" ||
            code === "ArrowDown" ||
            code === "ArrowLeft" ||
            code === "ArrowRight" ||
            code === "Space"
          ) {
            event.preventDefault();
          }

          keysDown.add(code);

          if (code === "Space" && gameState === "playing") {
            useRiftPulse();
          } else if ((code === "Enter" || code === "NumpadEnter") && gameState !== "playing") {
            startRun();
          }
        });

        window.addEventListener("keyup", (event) => {
          keysDown.delete(event.code);
        });

        riftBtn.addEventListener("click", useRiftPulse);
        startBtn.addEventListener("click", startRun);
        restartBtn.addEventListener("click", startRun);
        soundBtn.addEventListener("click", () => {
          soundOn = !soundOn;
          writeString(SOUND_KEY, soundOn ? "1" : "0");
          updateSoundLabel();
          playBeep(soundOn ? 920 : 280, 0.08, "square", 0.04);
        });

        window.addEventListener("resize", resizeCanvasCss);

        function initJoystick(zone, playerId) {
          const base = zone.querySelector(".joy-base");
          const knob = zone.querySelector(".joy-knob");
          const stick = {
            zone,
            base,
            knob,
            playerId,
            pointerId: null,
            originX: 0,
            originY: 0,
            lastTapAt: 0,
          };

          zone.addEventListener("pointerdown", (event) => onJoystickDown(event, stick));
          zone.addEventListener("pointermove", (event) => onJoystickMove(event, stick));
          zone.addEventListener("pointerup", (event) => onJoystickUp(event, stick));
          zone.addEventListener("pointercancel", (event) => onJoystickUp(event, stick));
          return stick;
        }

        function onJoystickDown(event, stick) {
          if (gameState !== "playing" || stick.pointerId !== null) return;
          event.preventDefault();

          const now = performance.now();
          if (now - stick.lastTapAt < 280) {
            const player = stick.playerId === "left" ? players.left : players.right;
            triggerDash(player);
          }
          stick.lastTapAt = now;

          stick.pointerId = event.pointerId;
          stick.zone.setPointerCapture(event.pointerId);

          const point = localPointInElement(event, stick.zone);
          stick.originX = point.x;
          stick.originY = point.y;

          stick.base.classList.add("active");
          stick.base.style.left = `${stick.originX}px`;
          stick.base.style.top = `${stick.originY}px`;
          stick.knob.style.transform = "translate(-50%, -50%)";
          joystickState[stick.playerId].x = 0;
          joystickState[stick.playerId].y = 0;
        }

        function onJoystickMove(event, stick) {
          if (stick.pointerId !== event.pointerId || gameState !== "playing") return;
          event.preventDefault();
          const point = localPointInElement(event, stick.zone);
          const dx = point.x - stick.originX;
          const dy = point.y - stick.originY;
          const radius = 38;
          const dist = Math.hypot(dx, dy);
          const scale = dist > radius ? radius / dist : 1;

          const ux = dx * scale;
          const uy = dy * scale;
          joystickState[stick.playerId].x = ux / radius;
          joystickState[stick.playerId].y = uy / radius;
          stick.knob.style.transform = `translate(calc(-50% + ${ux}px), calc(-50% + ${uy}px))`;
        }

        function onJoystickUp(event, stick) {
          if (stick.pointerId !== event.pointerId) return;
          event.preventDefault();
          try {
            stick.zone.releasePointerCapture(event.pointerId);
          } catch (_) {
            // Ignore pointer-capture release race
          }
          stick.pointerId = null;
          joystickState[stick.playerId].x = 0;
          joystickState[stick.playerId].y = 0;
          stick.base.classList.remove("active");
          stick.knob.style.transform = "translate(-50%, -50%)";
        }

        function localPointInElement(event, el) {
          const rect = el.getBoundingClientRect();
          return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
          };
        }

        // -------------------- Utils --------------------
        function rand(min, max) {
          return min + Math.random() * (max - min);
        }

        function clamp(v, min, max) {
          return Math.max(min, Math.min(max, v));
        }

        function readNumber(key, fallback) {
          try {
            const raw = localStorage.getItem(key);
            if (raw == null) return fallback;
            const n = Number(raw);
            return Number.isFinite(n) ? n : fallback;
          } catch (_) {
            return fallback;
          }
        }

        function readString(key, fallback) {
          try {
            const raw = localStorage.getItem(key);
            return raw == null ? fallback : raw;
          } catch (_) {
            return fallback;
          }
        }

        function writeNumber(key, value) {
          try {
            localStorage.setItem(key, String(value));
          } catch (_) {
            // Ignore quota/restricted mode.
          }
        }

        function writeString(key, value) {
          try {
            localStorage.setItem(key, value);
          } catch (_) {
            // Ignore quota/restricted mode.
          }
        }

        function resizeCanvasCss() {
          const maxW = window.innerWidth;
          const maxH = window.innerHeight;
          const scale = Math.min(maxW / WORLD_W, maxH / WORLD_H);
          const w = Math.floor(WORLD_W * scale);
          const h = Math.floor(WORLD_H * scale);
          shell.style.width = `${w}px`;
          shell.style.height = `${h}px`;
        }

        function updateSoundLabel() {
          soundBtn.textContent = soundOn ? "Sound ON" : "Sound OFF";
        }

        function ensureAudio() {
          if (audioCtx) return;
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) return;
          audioCtx = new AC();
        }

        function playBeep(freq, durSec, type, gain) {
          if (!soundOn) return;
          ensureAudio();
          if (!audioCtx) return;
          if (audioCtx.state === "suspended") {
            audioCtx.resume().catch(() => {});
          }
          const t = audioCtx.currentTime;
          const osc = audioCtx.createOscillator();
          const amp = audioCtx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, t);
          amp.gain.setValueAtTime(0.0001, t);
          amp.gain.exponentialRampToValueAtTime(gain, t + 0.01);
          amp.gain.exponentialRampToValueAtTime(0.0001, t + durSec);
          osc.connect(amp);
          amp.connect(audioCtx.destination);
          osc.start(t);
          osc.stop(t + durSec + 0.03);
        }
      })();
    </script>
  </body>
</html>
