<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Pac-Man (single file)</title>
  <style>
    :root{
      --cell: 20px;          /* size of a grid square */
      --bg: #001b2e;
      --wall: #143b5b;
      --wall-edge: #7fffd4;
      --dot: #fff6b3;
      --power: #ffd23f;
      --pm: #ffd23f;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 50% -200px,#02213b 0,#00121e 60%,#000 100%) fixed;color:#7fffd4;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:10px}
    h1{font-size:18px;margin:10px 0 0 0}
    .hud{display:flex;gap:12px;align-items:center}
    .pill{border:2px solid var(--wall-edge);border-radius:8px;padding:6px 10px;background:rgba(0,0,0,.35)}
    .grid{
      width: calc(28 * var(--cell));
      display:grid;
      grid-template-columns: repeat(28, var(--cell));
      grid-auto-rows: var(--cell);
      border:2px solid #07314c;border-radius:10px;
      box-shadow: 0 10px 40px rgba(0,0,0,.45), inset 0 0 0 2px rgba(127,255,212,.08);
      background: #01111d;
      touch-action: none;
    }
    .grid div{box-sizing:border-box}

    /* Tiles */
    .wall{background: var(--wall); outline: 2px solid var(--wall-edge)}
    .pac-dot{position:relative}
    .pac-dot::after{
      content:""; position:absolute; inset:0;
      margin:auto; width:6px; height:6px; border-radius:50%;
      background: var(--dot); box-shadow: 0 0 8px rgba(255,246,179,.9);
    }
    .power-pellet{position:relative}
    .power-pellet::after{
      content:""; position:absolute; inset:0;
      margin:auto; width:12px; height:12px; border-radius:50%;
      background: var(--power); box-shadow: 0 0 10px rgba(255,210,63,.95);
      animation: pulse 0.7s infinite alternate;
    }
    @keyframes pulse{from{transform:scale(.9)}to{transform:scale(1.05)}}
    .ghost-lair{background: rgba(20,59,91,.15)}
    /* Actors */
    .pac-man{
      background: var(--pm);
      border-radius:50%;
      box-shadow: 0 0 10px rgba(255,210,63,.8);
      position:relative;
    }
    .pac-man::before{ /* simple “mouth” wedge that rotates */
      content:"";
      position:absolute; inset:0; margin:auto; width:100%; height:100%;
      background: conic-gradient(transparent 0 40deg, #0000 40deg 320deg, transparent 320deg);
      border-radius:50%;
      transform: rotate(var(--rot,0deg));
    }
    .ghost{
      background:#f66; border-radius: 10px 10px 3px 3px / 10px 10px 6px 6px;
      position:relative; overflow:hidden;
    }
    .ghost::after{ /* eyes */
      content:""; position:absolute; top:4px; left:4px; width:12px; height:8px; border-radius:6px; background:#fff;
      box-shadow: 12px 0 0 #fff;
    }
    .ghost.scared-ghost{ background:#1e90ff; filter: drop-shadow(0 0 6px rgba(30,144,255,.9)); }
    .blinky{ background:#ff3b3b }
    .pinky { background:#ff8dd1 }
    .inky  { background:#00e1ff }
    .clyde { background:#ffb24c }

    /* mobile note */
    .note{font-size:12px;opacity:.8}
    @media (max-width:640px){
      :root{ --cell: 16px }
      h1{font-size:16px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Pac-Man</h1>
    <div class="hud">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">How to play: use arrow keys (or swipe)</div>
    </div>
    <div class="grid" aria-label="Pac-Man grid"></div>
    <div class="note">If ghosts look stuck, it means walls sealed them. This layout keeps an open exit.</div>
  </div>

  <script>
  // Single-file Pac-Man (grid version, robust + simple)
  document.addEventListener("DOMContentLoaded", () => {
    const grid = document.querySelector(".grid");
    const scoreEl = document.getElementById("score");
    const width = 28;               // grid is 28 x 28
    const squares = [];
    let score = 0;

    // Tile legend:
    // 0 pac-dot, 1 wall, 2 ghost-lair, 3 power-pellet, 4 empty
    // This layout is a lightly tweaked, working 28x28 board with a clear lair exit.
    const layout = [
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
      1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,
      1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,
      1,3,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,3,1,
      1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,
      1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
      1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,
      1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,
      1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,
      1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,
      1,1,1,1,1,1,0,1,1,4,4,4,4,4,4,4,4,4,4,1,1,0,1,1,1,1,1,1,
      1,1,1,1,1,1,0,1,1,4,1,1,1,4,4,1,1,1,4,1,1,0,1,1,1,1,1,1,
      1,1,1,1,1,1,0,1,1,4,1,2,2,4,4,2,2,1,4,1,1,0,1,1,1,1,1,1,
      4,4,4,4,4,4,0,0,0,4,1,2,2,2,2,2,2,1,4,0,0,0,4,4,4,4,4,4,
      1,1,1,1,1,1,0,1,1,4,1,2,2,2,2,2,2,1,4,1,1,0,1,1,1,1,1,1,
      1,1,1,1,1,1,0,1,1,4,1,1,1,4,4,1,1,1,4,1,1,0,1,1,1,1,1,1,
      1,1,1,1,1,1,0,1,1,4,1,1,1,4,4,1,1,1,4,1,1,0,1,1,1,1,1,1,
      1,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,1,
      1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,
      1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,
      1,3,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,3,1,
      1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,
      1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,
      1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,
      1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,
      1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,
      1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    ];

    // Build board
    function createBoard(){
      for (let i=0;i<layout.length;i++){
        const square = document.createElement("div");
        square.id = i;
        // set base classes
        if (layout[i] === 0) square.classList.add("pac-dot");
        if (layout[i] === 1) square.classList.add("wall");
        if (layout[i] === 2) square.classList.add("ghost-lair");
        if (layout[i] === 3) square.classList.add("power-pellet");
        // 4 = empty (no class)
        grid.appendChild(square);
        squares.push(square);
      }
    }
    createBoard();

    // Place actors
    let pacmanIndex = 490;  // valid empty tile in this layout
    squares[pacmanIndex].classList.add("pac-man");

    const ghosts = [
      { className:"blinky", start: 348, speed: 250, index: 348, scared:false, timer: null },
      { className:"pinky",  start: 376, speed: 400, index: 376, scared:false, timer: null },
      { className:"inky",   start: 351, speed: 300, index: 351, scared:false, timer: null },
      { className:"clyde",  start: 379, speed: 500, index: 379, scared:false, timer: null },
    ];
    ghosts.forEach(g=>{
      squares[g.index].classList.add(g.className,"ghost");
    });

    // Pac-Man movement (keyboard + swipe)
    document.addEventListener("keydown", e => movePacman(e.key));
    // Simple swipe for mobile
    let touchStart=null;
    grid.addEventListener("touchstart",(e)=>{ const t=e.changedTouches[0]; touchStart={x:t.clientX,y:t.clientY}; },{passive:true});
    grid.addEventListener("touchend",(e)=>{
      if(!touchStart) return;
      const t=e.changedTouches[0], dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y;
      if (Math.max(Math.abs(dx),Math.abs(dy))>20){
        if (Math.abs(dx)>Math.abs(dy)) movePacman(dx>0?"ArrowRight":"ArrowLeft");
        else movePacman(dy>0?"ArrowDown":"ArrowUp");
      }
      touchStart=null;
    },{passive:true});

    function movePacman(key){
      squares[pacmanIndex].classList.remove("pac-man");
      // update rotation for visual mouth direction
      const setRot=(deg)=>{ squares[pacmanIndex].style.setProperty("--rot",deg+"deg"); };

      if (key==="ArrowLeft"){
        if (pacmanIndex % width !== 0 &&
            !squares[pacmanIndex-1].classList.contains("wall") &&
            !squares[pacmanIndex-1].classList.contains("ghost-lair")){
          pacmanIndex -= 1; setRot(180);
        } else setRot(180);
        // wrap left tunnel
        if (pacmanIndex===363) pacmanIndex = 391;
      }
      else if (key==="ArrowRight"){
        if (pacmanIndex % width < width-1 &&
            !squares[pacmanIndex+1].classList.contains("wall") &&
            !squares[pacmanIndex+1].classList.contains("ghost-lair")){
          pacmanIndex += 1; setRot(0);
        } else setRot(0);
        // wrap right tunnel
        if (pacmanIndex===392) pacmanIndex = 364;
      }
      else if (key==="ArrowUp"){
        if (pacmanIndex - width >= 0 &&
            !squares[pacmanIndex-width].classList.contains("wall") &&
            !squares[pacmanIndex-width].classList.contains("ghost-lair")){
          pacmanIndex -= width; setRot(270);
        } else setRot(270);
      }
      else if (key==="ArrowDown"){
        if (pacmanIndex + width < width*width &&
            !squares[pacmanIndex+width].classList.contains("wall") &&
            !squares[pacmanIndex+width].classList.contains("ghost-lair")){
          pacmanIndex += width; setRot(90);
        } else setRot(90);
      }

      squares[pacmanIndex].classList.add("pac-man");
      eatDot(); eatPower(); checkGameOver(); checkWin();
    }

    function eatDot(){
      if (squares[pacmanIndex].classList.contains("pac-dot")){
        squares[pacmanIndex].classList.remove("pac-dot");
        score++; scoreEl.textContent = score;
      }
    }
    function eatPower(){
      if (squares[pacmanIndex].classList.contains("power-pellet")){
        squares[pacmanIndex].classList.remove("power-pellet");
        score += 10; scoreEl.textContent = score;
        ghosts.forEach(g=>g.scared=true);
        setTimeout(()=>ghosts.forEach(g=>g.scared=false), 7000);
      }
    }

    // Ghost movement (random roam, won’t jitter in place)
    ghosts.forEach(g=> moveGhost(g));
    function moveGhost(g){
      const dirs = [-1, 1, width, -width];
      let dir = dirs[Math.floor(Math.random()*dirs.length)];
      g.timer = setInterval(()=>{
        const next = g.index + dir;

        const blocked =
          squares[next].classList.contains("wall") ||
          squares[next].classList.contains("ghost");

        if (!blocked){
          squares[g.index].classList.remove(g.className,"ghost","scared-ghost");
          g.index = next;
          squares[g.index].classList.add(g.className,"ghost");
        } else {
          // pick a new direction (try up to 10 times to avoid ping-pong)
          for (let tries=0; tries<10; tries++){
            const maybe = dirs[Math.floor(Math.random()*dirs.length)];
            const test = g.index + maybe;
            if (!squares[test].classList.contains("wall") &&
                !squares[test].classList.contains("ghost")){
              dir = maybe; break;
            }
          }
        }

        // visual scared state
        if (g.scared){
          squares[g.index].classList.add("scared-ghost");
          // If Pac-Man meets scared ghost → eat it
          if (squares[g.index].classList.contains("pac-man")){
            squares[g.index].classList.remove(g.className,"ghost","scared-ghost");
            g.index = g.start; // return to lair start
            score += 100; scoreEl.textContent = score;
            squares[g.index].classList.add(g.className,"ghost");
          }
        } else {
          squares[g.index].classList.remove("scared-ghost");
        }

        // check collision (not scared)
        checkGameOver();
      }, g.speed);
    }

    function checkGameOver(){
      if (squares[pacmanIndex].classList.contains("ghost") &&
          !squares[pacmanIndex].classList.contains("scared-ghost")){
        ghosts.forEach(g=>clearInterval(g.timer));
        alert("Game Over");
      }
    }
    function checkWin(){
      // You can tweak this number depending on how many dots you want to count as a win
      if (score >= 274){
        ghosts.forEach(g=>clearInterval(g.timer));
        alert("You WIN!");
      }
    }
  });
  </script>
</body>
</html>
